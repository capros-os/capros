<HTML>
<HEAD>
<TITLE>Kernel Event Handling in EROS</TITLE>
</HEAD>
<BODY>
<P>
The EROS kernel architecture is event driven.  This note describes the
various kinds of kernel events, how they are created, and the way they
are routed and dispatched through the kernel.  Because the conversion
to the event model is incomplete, the kernel may not always be
consistent with this note.  In such cases, this note should be viewed
as reflecting the <EM>intended</EM> design, and the relevant kernel
code should be brought up to date.
<P>
<H1>1. Types of EROS Events</H1>
<P>
There are several types of events handled by the EROS kernel.  Most
relate to hardware interrupts or instruction faults.
<P>
<STRONG>Note Bene:</STRONG> the event terminology used in EROS may or
may not conform to the usages of your favorite processor manual.  The EROS
lexicon comes from my days doing distributed multiarchitecture
debuggers, so the event model supported by EROS should be portable to
multiple architectures.
<P>
Here are the kinds of events supported by EROS:
<DL>
<DT> Invalid
<DD> 
This event type should never actually be generated.  It exists as a
placeholder to use in interrupt vector tables where the processor
architecture specifies a "reserved" interrupt.  If your hardware
generates one of these, you are scrod (that's the past pluperfect).
It is certainly time to reboot the machine, and quite possible time to
replace your processor chip with a less buggy revision.
<P>
<DT> Fault
<DD> 
Generated as a side effect of processing some instruction.  The PC
points to the instruction that caused the event, so no funny business
is required in order to restart the process that generated the event.
<P>
<DT> Trap
<DD> 
Generated as a side effect of processing some instruction.  PC points
to the instruction AFTER the one that caused the event.  Most hardware
implements kernel entry mechanisms with traps.  A few (regrettably)
implement breakpoints this way, which is unfortunate.
<P>
Just because the PC points to the following instruction does not mean
that it needs to be backed up.  In some cases, most notably traps, it
is proper to restart the process with the PC left where it is.  
<P>
<DT> Exception
<DD> 
Generated as a side effect of processing some instruction.
This event will prove to be either a <STRONG>fault</STRONG> or a
<STRONG>trap</STRONG>, but due to a screwed up hardware design further
analysis is required to determine which one.  Once that analysis is
done, the event type will be smashed to be either a fault or a trap.
<P>
<DT> Abort
<DD> 
Generated as a side effect of processing some instruction.
Not recoverable.
<P>
In practice, this occurs only for the <STRONG>double fault</STRONG>
exception, and the typical response is to reboot the machine.
<P>
<DT> Interrupt
<DD> 
Generated by a hardware event.  The PC points to the instruction we
will restart.  Theoretically, since this is sw-independent, processing
an interrupt event should not require access to the active register
set.
<P>
<DT> Timer
<DD> 
Generated indirectly by the motherboard clock interrupt.  Used for
watchdogs, sleep queues, etc. etc.
</DL>
<P>
On some architectures, it is possible for user code to invoke a
"software interrupt" instruction.  In EROS, such invocations are
encapsulated and sent to the domain keeper.

<H1>2. Handlers and Devices</H1>
<P>
A <STRONG>handler</STRONG> is an object that responds to events.  All
events generated by the hardware have an associated handler.  On the
i386 machine, for example, a page fault event is routed to the
<CODE>PageFaultDrvr</CODE> object, whose <STRONG>OnEvent</STRONG>
routine performs appropriate further processing depending on whether
the page fault occurred in the kernel or in a user task.
<P>
A <STRONG>device</STRONG> is a handler that in addition can have
associated keys.  In addition to the <STRONG>OnEvent</STRONG> entry
point, a device implements an <STRONG>OnKeyCall</STRONG> entry point
that is invoked by the key invocation logic.  Hardware controllers and
their associated units are typically implemented as a subclass of the
<CODE>Device</CODE> class.
<P>
Because of the dispatching style, event handling can be delegated.  A
SCSI host adaptor that supports disconnected operation will typically
examine its state to determine which unit should receive the event and
direct the event on to the unit itself.
<P>
Not all devices correspond to physical hardware.  A number of kernel
provided services (such as <STRONG>discrim</STRONG>) are implemented
by objects derived from the Device class.  These service objects
typically do not implement event handler logic.
<H2>2.1. Kernel Initialization</H2>
<P>
On startup, the kernel must somehow contrive to initialize all of the
event handlers in the system.  The net effect of initialization is
that each handler registers itself appropriately to receive events and
gets an opportunity to allocate and initialize any private memory that
the handler object will need.
<P>
Before examining the handlers, the kernel first performs some
machine-dependent work in order to determine how much main memory is
available.  It then invokes the <STRONG>Probe</STRONG> routine of each
handler object known to the kernel.  The job of the probe routine is
to determine whether the hardware corresponding to that handler object
is actually present.  If the handler corresponds to a processor
exception (e.g. page fault handler) or a kernel service, the probe
routine is trivial.
<P>
If the handler object corresponds to a hardware controller, it should
perform whatever actions are necessary to determine whether the
associated hardware is actually installed.  A typically configured
EROS kernel will include device drivers for many more disk controller
types than the system will actually have.  Most of these will learn
during the probe phase that no hardware is installed.
<P>
If the handler corresponds to a slave device (e.g. a unit on a disk
controller), the kernel does not probe the device.  Slave device
probes are performed when their associated parent device (in this case
the controller) is attached.
<H3>2.1.1. Probe Order</H3>
<P>
On most machines, there are ordering constraints on how drivers are
initialized.  For example, the system timer must be initialized before
almost anything else, since many other drivers make use of watchdog
timers.
<P>
There are also some less obvious constraints.  Not all controllers are
friendly to autoconfiguration, so it is sometimes important to probe
for one kind of board before another.  On the i386, for example,
ethernet boards are (in)famous for locking up if probed in certain
ways.  Unfortunately, the usual CD-ROM controller probe logic locks up
the ethernet boards.  The best solution is to probe for the ethernet
boards first, and then avoid them when probing for sound boards.
<P>
In order to handle these sorts of problems,the kernel initialization
logic makes several passes.  Each driver is marked with the pass in
which its initialization should occur.  Motherboard components are
initialized first, followed by controllers whose probe routines are
"friendly", followed by difficult cases.  The general idea is to
ensure that probe conflicts are avoided by registering the easy to
recognize hardware first and then looking at the difficult cases.
</BODY>
</HTML>
