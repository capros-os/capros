<html>
<head>
<title>EOR: Process</title>
</head>

<BODY BGCOLOR="#ffeedd" text="#000000" link="#0000ee" vlink="#551a8b" alink="#ff0000"><table><tr valign=top><td width="10%">&nbsp;</td><td><div class=nocss><br class=nocss>&nbsp;<br class=nocss>&nbsp;</div>
<div class=KeyName>
  [<em><a href="../Cover.html">Return to Top</a></em>]
  [<em><a href="00Primary.html">Primary Objects</a></em>]
  <div align=right>
    <H2>EROS Object Reference</H2>
    <H2>Primary Objects</H2>
  </div>
  <h2>Process</h2>
  <em>D R A F T</em>
  <hr>
</div>
<div class=KeyDescrip>
  <h3>Description</h3>
  <p> A process defines the
  environment and access rights available to the program executing
  within that process.  Among these, the process contains an address
  space containing the program code for that process.  We say that the
  process <em>obeys</em> this program.
  <p> Processes can be in one of three states:
  <table>
    <tr valign=top>
      <td><strong>Available</strong></td>
      <td>The process is available for entry by a thread via a <em>start
	key</em>.  Equivalently, the process is available to provide
	services to its clients.  Attempts to invoke a start key to a
	non-available process block until the process becomes available.</td>
    </tr>
    <tr valign=top>
      <td><strong>Running</strong></td>
      <td>The process is currently occupied by a thread, which is
	executing instructions from the process's address space</td>
    </tr>
    <tr valign=top>
      <td><strong>Waiting</strong></td>
      <td>The thread that last occupied this process performed a CALL
	operation, and the process is waiting for the <em>resume
	key</em> generated by that call to be invoked.  A waiting
	process will be resumed at most once; the invocation of any
	copy of the resume key invalidates all other resume keys.</td>
    </tr>
  </table>
  <p> A <strong>process key</strong> conveys complete authority over
  the process, including the authority to alter its address space or
  registers, fabricate start keys, change the process's state.  It is
  possible to perform operations using the process key that result in a
  malformed (and therefore unrunnable) process.
  <p> Typically, the process key conveys <em>greater</em> authority
  over the process than is enjoyed by the program that the process
  obeys.
  <p> Process key operations may be performed while the subject process
  is running.  Such operations are atomic with respect to the subject
  process.  The externally visible effect of such an operation will be
  as if the operation were performed between the completion of one
  instruction and the initiation of the next.
  <h4>1 Process Layout</h4>
  <p> The layout of a process is architecture dependent, but many
  aspects of process layout are common across all 32-bit
  architectures.  A minimal process consists of a single Node: the
  process root.  The layout of this Node is as follows:
    <center>
      <table border width=90%>
	<caption>
	  <strong>Process Root</strong>
	</caption>
	<tr valign=top>
	  <th align=left width=5%>
	    Slot
	  </th>
	  <th align=left width=45%>
	    Usage
	  </th>
	  <th align=left width=5%>
	    Slot
	  </th>
	  <th align=left width=45%>
	    Usage
	  </th>
	</tr>
	<tr valign=top>
	  <td>
	    DR0
	  </td>
	  <td>
	    Schedule Class key
	  </td>
	  <td>
	    DR16
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR1
	  </td>
	  <td>
	    Keeper key
	  </td>
	  <td>
	    DR17
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR2
	  </td>
	  <td>
	    Address space key
	  </td>
	  <td>
	    DR18
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR3
	  </td>
	  <td>
	    Key registers node key (if present). <em>This slot will
			someday hold the capability space.</em>
	  </td>
	  <td>
	    DR19
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR4
	  </td>
	  <td>
	    I/O address space key.
	  </td>
	  <td>
	    DR20
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR5
	  </td>
	  <td>
	    <em>Reserved for Symbol table space key.</em>
	  </td>
	  <td>
	    DR21
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR6
	  </td>
	  <td>
	    Brand key
	  </td>
	  <td>
	    DR22
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR7
	  </td>
	  <td>
	    <strong>Register slot</strong>
	    <br> Bytes 0-3: Fault Code
	    <br> Bytes 4-7: Fault Info
	    <br> Byte 8: Run state (available, running, waiting)
	    <br> Byte 8: Process flags byte.
	  </td>
	  <td>
	    DR23
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR8
	  </td>
	  <td>
	    <strong>Register slot</strong>
	    <br> Bytes 0-3: PC
	    <br> Bytes 4-7: SP
	  </td>
	  <td>
	    DR24
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR9
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	  <td>
	    DR25
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR10
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	  <td>
	    DR26
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR11
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	  <td>
	    DR27
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR12
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	  <td>
	    DR28
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR13
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	  <td>
	    DR29
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR14
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	  <td>
	    DR30
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
	<tr valign=top>
	  <td>
	    DR15
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	  <td>
	    DR31
	  </td>
	  <td>
	    <strong>Architecture Defined</strong>
	  </td>
	</tr>
      </table>
    </center>
  <h5>1.1 Architecture-Defined Slots</h5>
  <p> Certain slots are architecture-defined, and are used to store
  architecture-specific register values.  Spillover from the space
  available in the process root is <em>usually</em> handled by placing
  the remaining registers in the general registers Node.  While this is
  the customary structure of a process, there are some exceptions:
    <center>
      <table width=90%>
	<tr valign=top>
	  <td><strong>x86 family</strong></td>
	  <td>All registers (both fixed and floating point) fit in the
	    process root.  Four pseudo-registers are defined by the
	    architecture to carry invocation-related information.</td>
	</tr>
	<tr valign=top>
	  <td><strong>32-bit SPARC family</strong></td>
	  <td> This machine has approximately 632 bytes of user-mode
	    register state (I may have missed one or two), requiring a
	    total of 53 number keys to hold user-mode register state.  The
	    process root has 23 architecture-defined registers, one of
	    which is used to name an annex register node.  If an
	    additional node were required, a natural partitioning would be
	    to isolate floating point state in its own node, since most
	    processes do not use the floating point engine.</td>
	</tr>
	<tr valign=top>
	  <td><strong>32-bit MIPS family</strong></td>
	  <td> All registers (both fixed and floating point) fit in the
	    process root.</td>
	</tr>
	<tr valign=top>
	  <td><strong>64-bit SPARC family</strong></td>
	  <td>In a full implementation, the 64-bit SPARC machine has 1216
	    bytes of user-mode register state, requiring a total of 102
	    number keys to contain them.  <em>Three</em> annex nodes are
	    required to hold this state.  As with the 32-bit SPARC chip,
	    the division of state does not admit of a convenient
	    segregation of floating-point registers to reduce space.</td>
	</tr>
      </table>
    </center>
    <h5>1.2 Invocation Send and Receive Information</h5>
    <p>The EROS architecture defines a key invocation to pass
    four registers, four keys, and up to 64 Kbytes of data in
    each direction.  
    <p>
    The registers passed by the invocation are
    architecture-specific. The passing of these registers is
    unconditional, because making it conditional is just as expensive
    as saving and restoring these registers.
    <p>
    The passing of keys is similarly unconditional, but the sender and
    receiver have control over <em>which</em> registers are passed and
    into which registers the incoming values are received.  Because
    key register zero is ``hardwired'' to the
    <a href="../kernel/Void.html"><strong>void key</strong></a>, the
    transmitted capabilities can be directed to or from key register
    zero to achieve the effect of not sending any authority.
    <p> The message send and receive control blocks, then, must
    provide several pieces of information:
    <ul>
      <li> The type of the invocation.
      <li> A value describing which key register is to be invoked.
      <li> A value describing which four key registers are to be sent.
      <li> A value describing which four key registers are to receive
	   the incoming keys.
      <li> A pointer to the data buffer to be sent.
      <li> The length of this send buffer.
      <li> A pointer to the location where incoming data should be received.
      <li> The length of this incoming buffer.
    </ul>
    <p> While the placement of these values in registers or memory is
    architecture specific, all 32-bit implementations share a common
    encoding of this information:
    <ul>
      <li> The send and receive pointers occupy a full 32-bit value each.
	   <p>
      </li>
      <li> The send and receive length fields occupy a full 32-bit
	   value each.  On return, the receive length register
	   contains the length of the string received, which is &lt;=
	   the receive length bound.
	   A zero value in either length field indicates that no data
	   is to be sent (received).  In this event, the process may
	   assume that the data pointer register(s) are not modified
	   by the invocation.
	   <p>
      </li>
      <li> The type of the invocation (reply = 0x0, call = 0x1, or
	   send = 0x2) is
	   encoded as a full 32-bit value.  <em>This may yet be merged
	   into the receive keys word below.</em>
	   <p>
      </li>
      <li> The sent key register names are encoded into a single
	   32-bit word as follows:
	   <center>
	     <pre>
 31  20 19  15 14  10 9    5 4    0
+------+------+------+------+------+
| zero | key3 | key2 | key1 | key0 |
+------+------+------+------+------+
	     </pre>
	   </center>
	   Bits marked zero are reserved for future use.
	   <p>
      </li>
      <li> The receive key register names and the invoked key
	   are encoded into a single 32-bit word as follows:
	   <center>
	     <pre>
31  25 24     20 19  15 14  10 9    5 4    0
+------+---------+------+------+------+------+
| zero | inv key | key3 | key2 | key1 | key0 |
+------+---------+------+------+------+------+
	     </pre>
	   </center>
	   Bits marked zero are reserved for future use.
	   <p> Encoding the invoked key along with the receive keys
	   allows for a faster implementation on register-starved
	   architectures.
	   <p>
      </li>
    </ul>
  <h5>1.4 Key Registers</h5>
    <p> Native EROS processes  possess 32 key registers, which are
    contained in the key registers Node.  Emulation processes are marked
    by a bit in the trap code key, and do not require a key registers
    Node (<em>not yet implemented - for now, provide a key registers
    Node for all processes</em>).  The key register slots are referred to
    as <strong>KR0</strong> through <strong>KR31</strong>.
  <p> In the following descriptions, certain operations are defined in
  terms of the slots of the process root Node
  <hr>
  <h3>Operations</h3>
  <dl>
    <dt> <strong>Check Alleged Key Type</strong> (OC = KT)
    <dd> 
	 <p> Returns the alleged type of the key.
	 <table>
	   <tr valign=top>
	     <td rowspan=1>
	       <strong>Reply</strong>
	     </td>
	     <td>
               <strong>R1</strong>
	     </td>
	     <td align=right>
	       <em>AKT_Process</em>:
	       Key is a process key.
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Copy Key</strong> (OC = 0)
    <dd> 
	 <p> Retrieves the key from slot <strong>N</strong> (0
	 &lt;= N &lt; 32) of the process root.  The process root slot may
	 not be the brand slot.
	 <table>
	   <tr valign=top>
	     <td>
	       <strong>Request</strong>
	     </td>
	     <td align=right>
	       R1
	     </td>
	     <td>
	       The slot to be fetched.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td>
	       <strong>Reply</strong>
	     </td>
	     <td align=right>
	       RK0
	     </td>
	     <td>
	       A copy of the requested key.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td rowspan=4>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       Operation completed successfully.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       RC_RequestError
	     </td>
	     <td>
	       Invalid slot, or brand slot requested.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_NoKeys</em>
	     </td>
	     <td>
	       Process has no key registers.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_Malformed</em>
	     </td>
	     <td>
	       Process is malformed.
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Swap Key</strong> (OC = 1)
    <dd> 
	 <p> Exchanges the key in slot <strong>N</strong> (0
	 &lt;= N &lt; 32) of the process root with the passed key.
         The returned key can be  
	 suppressed by specifying RK0 as the return key register. The
	 process root slot may not be the brand slot.
	 <table>
	   <tr valign=top>
	     <td rowspan=2>
	       <strong>Request</strong>
	     </td>
	     <td align=right>
	       R1
	     </td>
	     <td> The slot <strong>N</strong> to be fetched.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       SK0
	     </td>
	     <td> The key to be placed in slot <strong>N</strong>.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td>
	       <strong>Reply</strong>
	     </td>
	     <td align=right>
	       RK0
	     </td>
	     <td> A copy of the key that previously occupied slot
	       <strong>N</strong>.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td rowspan=5>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       Operation completed successfully.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_RequestError</em>
	     </td>
	     <td>
	       Invalid slot, or brand slot requested.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_NoKeys</em>
	     </td>
	     <td>
	       Process has no key registers.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_Malformed</em>
	     </td>
	     <td>
	       Process is malformed.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_Returnee</em>
	     </td>
	     <td> Operation would modify the returnee.  This usually
	       means that the process key names the same process that is
	       named by the resume key for this operation.
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Copy Key Register</strong> (OC = 2)
    <dd> 
	 <p> Retrieves the key from key register <strong>N</strong> (0
	 &lt;= N &lt; 32) of the process.
	 <table>
	   <tr valign=top>
	     <td>
	       <strong>Request</strong>
	     </td>
	     <td align=right>
	       R1
	     </td>
	     <td>
	       The slot to be fetched.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td>
	       <strong>Reply</strong>
	     </td>
	     <td align=right>
	       RK0
	     </td>
	     <td>
	       A copy of the requested key.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td rowspan=4>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       Operation completed successfully.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       RC_RequestError
	     </td>
	     <td>
	       Invalid slot number.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_NoKeys</em>
	     </td>
	     <td>
	       Process has no key registers.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_Malformed</em>
	     </td>
	     <td>
	       Process is malformed.
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Swap Key Register</strong> (OC = 3)
    <dd> 
	 <p> Exchanges the key in capability register <strong>N</strong> (0
	 &lt;= N &lt; 32) of the process with the passed key.
         The returned key can be  
	 suppressed by specifying RK0 as the return key register.
	 <table>
	   <tr valign=top>
	     <td rowspan=2>
	       <strong>Request</strong>
	     </td>
	     <td align=right>
	       R1
	     </td>
	     <td> The capability register number <strong>N</strong> to
                  be fetched. 
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       SK0
	     </td>
	     <td> The key to be placed in capability register <strong>N</strong>.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td>
	       <strong>Reply</strong>
	     </td>
	     <td align=right>
	       RK0
	     </td>
	     <td> A copy of the key that previously occupied
               capability register
	       <strong>N</strong>.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td rowspan=5>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       Operation completed successfully.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_RequestError</em>
	     </td>
	     <td>
	       Invalid slot, or brand slot requested.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_NoKeys</em>
	     </td>
	     <td>
	       Process has no key registers.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_Malformed</em>
	     </td>
	     <td>
	       Process is malformed.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_Returnee</em>
	     </td>
	     <td> Operation would modify the returnee.  This usually
	       means that the process key names the same process that is
	       named by the resume key for this operation.
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Get Registers (32 bit)</strong> (OC = 128)
    <dd> 
	 <p> Retrieves the complete set of register values from the
	 process.  The size and layout of the returned information is
	 architecture specific, but the portion of the layout
	 described below will be returned in the indicated locations
	 by all architectures:
	 <table>
	   <tr valign=top>
	     <td rowspan=5>
	       <strong>Reply</strong>
	     </td>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td> The processor architecture identifier, a byte-sex
	       independent palindrome.  Currently supported
	       architectures and their associated architecture codes
	       are:
	       <table>
		 <tr valign=top>
		   <th align=left>Processor</td>
		   <th align=left>Code</td>
		 </tr>
		 <tr valign=top>
		   <td>386/486/Pentium</td>
		   <td>0x0b0000b0</td>
		 </tr>
	       </table>
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td>
	       Size of reply message, in bytes.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td>
	       The current program counter.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td>
	       The current stack pointer.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <strong>W*</strong>
	     </td>
	     <td>
	       Remaining registers
	     </td>
	   </tr>
	   <tr valign=top>
	     <td rowspan=2>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       Operation completed successfully.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       2
	     </td>
	     <td>
	       The process was malformed. No action was taken.
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Set Registers (32 bit)</strong> (OC = 144)
    <dd> 
	 <p> Sets the complete set of register values from the
	 process.  The size and layout of the message is
	 architecture specific, but the portion of the layout
	 described below will be in the indicated locations for all 32
	 bit architectures.
	 <p> The provided message string must be the exact size of the
	 register information structure for the architecture, as
	 returned by <em>Get Registers (32 bit)</em>.
	 <table>
	   <tr valign=top>
	     <td rowspan=5>
	       <strong>Request</strong>
	     </td>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td>
	       The architecture identifier, a byte-sex independent
	       palindrome.
	     </td>
	     <td>
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td> Size of request buffer, in bytes.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td>
	       The current program counter.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td>
	       The current stack pointer.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <strong>W*</strong>
	     </td>
	     <td>
	       Remaining registers
	     </td>
	   </tr>
	   <tr valign=top>
	     <td rowspan=4>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       Operation completed successfully.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       2
	     </td>
	     <td>
	       The process was malformed. No action was taken.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_RequestError</em>
	     </td>
	     <td>
	       Insufficient length passed for message buffer, length
	       field of message is wrong, or architecture
	       field not for this architecture.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_Returnee</em>
	     </td>
	     <td> Operation would modify the returnee.  This usually
	       means that the process key names the same process that is
	       named by the resume key for this operation.
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Get Floating Point Registers</strong> (OC = 129)
    <dd> 
	 <p> Retrieves the floating point register set.  The size and
	 layout of the returned information is architecture specific,
	 but the portion of the layout described below will be
	 returned in the indicated locations by all architectures:
	 <table>
	   <tr valign=top>
	     <td rowspan=3>
	       <strong>Reply</strong>
	     </td>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td> The floating point architecture identifier, a
	       byte-sex independent palindrome.  Currently supported
	       architectures and their associated architecture codes
	       are:
	       <table>
		 <tr valign=top>
		   <th align=left>Processor</td>
		   <th align=left>Code</td>
		 </tr>
		 <tr valign=top>
		   <td>386/486/Pentium</td>
		   <td>0x0b0000b0</td>
		 </tr>
	       </table>
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td>
	       Size of reply message, in bytes.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <strong>W*</strong>
	     </td>
	     <td>
	       Remaining registers
	     </td>
	   </tr>
	   <tr valign=top>
	     <td rowspan=2>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       Operation completed successfully.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       2
	     </td>
	     <td>
	       The process was malformed. No action was taken.
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Set Floating Point Registers</strong> (OC = 145)
    <dd> 
	 <p> Sets the floating point register set values of the
	 process.  The size and layout of the message is architecture
	 specific, but the portion of the layout described below will
	 be in the indicated locations for all 32 bit architectures.
	 <p> The provided message string must be the exact size of the
	 register information structure for the architecture, as
	 returned by <em>Get Floatin Point Registers</em>.
	 <table>
	   <tr valign=top>
	     <td rowspan=3>
	       <strong>Request</strong>
	     </td>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td> The floating point architecture identifier, a
	       byte-sex independent palindrome.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td>
	       Size of request message, in bytes.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <strong>W*</strong>
	     </td>
	     <td>
	       Remaining registers
	     </td>
	   </tr>
	   <tr valign=top>
	     <td rowspan=4>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       Operation completed successfully.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       2
	     </td>
	     <td>
	       The process was malformed. No action was taken.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_RequestError</em>
	     </td>
	     <td>
	       Insufficient length passed for message buffer, length
	       field of message is wrong, or architecture
	       field not for this architecture.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_Returnee</em>
	     </td>
	     <td> Operation would modify the returnee.  This usually
	       means that the process key names the same process that is
	       named by the resume key for this operation.
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Swap Memory (32-bit)</strong> (OC = 192)
    <dd> 
	 <p> Swaps the process's address space key (slot DR2) with the
	 passed key and alters the value of the program counter in a
	 single atomic operation.
	 <table>
	   <tr valign=top>
	     <td rowspan = 2>
	       <strong>Request</strong>
	     </td>
	     <td align=right>
	       <strong>W</strong>
	     </td>
	     <td> The new program counter value.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       SK0
	     </td>
	     <td> The key to be placed in slot DR2.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td>
	       <strong>Reply</strong>
	     </td>
	     <td align=right>
	       RK0
	     </td>
	     <td>
	       A copy of the key that previously occupied DR2.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td rowspan=2>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       Operation completed successfully.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_RequestError</em>
	     </td>
	     <td>
	       Wrong message string length.
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Make Start Key</strong> (OC = 160)
    <dd>
	 <p> Fabricates a start key to the process, using the low-order
	 16 bits of the passed word as the key data field of the new key.
	 This order does <em>not</em> change the state of the process.
	 <table>
	   <tr valign=top>
	     <td rowspan = 1>
	       <strong>Request</strong>
	     </td>
	     <td align=right>
	       <strong>R1</strong>
	     </td>
	     <td> The key data field value of the new start key.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td>
	       <strong>Reply</strong>
	     </td>
	     <td align=right>
	       RK0
	     </td>
	     <td>
	       A start key to the process.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td rowspan=2>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       Operation completed successfully.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_RequestError</em>
	     </td>
	     <td>
	       Wrong message string length
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Make Resume Key</strong> (OC = 161)
    <dd>
	 <p> Fabricates a resume key to the process, placing the process
	 in the <em>waiting</em> state.
	 <table>
	   <tr valign=top>
	     <td>
	       <strong>Reply</strong>
	     </td>
	     <td align=right>
	       RK0
	     </td>
	     <td>
	       A resume key to the process, or a void key.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td rowspan=3>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       Operation completed successfully.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       1
	     </td>
	     <td> The process was running or waiting. No action
	       was taken, and the returned key is a void key.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       2
	     </td>
	     <td>
	       The process was malformed. No action was taken, and
	       the returned key is a void key.
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Make Fault Key</strong> (OC = 162)
    <dd>
	 <p> This operation is identical to <strong>Make Resume Key</strong>,
         except it also puts the process in a state in which it will not accept
         any message. Specifically, it clears the PF_ExpectingMsg bit in
         the process's processFlags field. You use this operation when the
         process's state is not set up to receive a message; invoking the
         Resume key simply puts the process in the Running state. 
	 <p> 
    <dt> <strong>Make Process Available</strong> (OC = 176)
    <dd>
	 <p> Changes the process to the <em>available</em> state,
	 invalidating all outstanding resume keys to the process and
	 destroying any thread that may currently occupy the process.
	 <table>
	   <tr valign=top>
	     <td rowspan=4>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       The process was available already.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       1
	     </td>
	     <td>
	       The process was running or waiting.  It is now available.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       2
	     </td>
	     <td>
	       The process was malformed. No action was performed.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_Returnee</em>
	     </td>
	     <td> Operation would modify the returnee.  This usually
	       means that the process key names the same process that is
	       named by the resume key for this operation.
	     </td>
	   </tr>
	 </table>
	 <p> 
    <dt> <strong>Make Process Waiting</strong> (OC = 177)
    <dd>
	 <p> Changes the process to the <em>waiting</em> state,
	 invalidating all outstanding resume keys to the process and
	 destroying any thread that may currently occupy the process.
	 <table>
	   <tr valign=top>
	     <td>
	       <strong>Reply</strong>
	     </td>
	     <td align=right>
	       RK0
	     </td>
	     <td>
	       A fault key to the process, or a void key.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td rowspan=4>
	       <strong>Result</strong>
	     </td>
	     <td align=right>
	       RC_OK
	     </td>
	     <td>
	       The process was available. The returned key is a fault
	       key to the process.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       1
	     </td>
	     <td>
	       The process was running or waiting.  The returned key is
	       a fault key to the process.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       2
	     </td>
	     <td>
	       The process was malformed. No action was performed.
	     </td>
	   </tr>
	   <tr valign=top>
	     <td align=right>
	       <em>RC_Process_Returnee</em>
	     </td>
	     <td> Operation would modify the returnee.  This usually
	       means that the process key names the same process that is
	       named by the resume key for this operation.
	     </td>
	   </tr>
	 </table>
	 <p> 
  </dl>
</div>
</td>
<td width="10%">&nbsp;</td>
</tr>
</table>
<hr>
<table>
<tr valign=top>
  <td width=92>
<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=132228&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
  </td>
  <td>
<em>Copyright 1998, 2001 by Jonathan Shapiro,
2007 by Strawberry Development Group.
All rights reserved.  For terms of redistribution, see the 
<a href="../../legal/license/GPL.html">GNU General Public License</a></em>
This material is based upon work supported by the US Defense Advanced
Research Projects Agency under Contract No. W31P4Q-07-C-0070.
Approved for public release, distribution unlimited.
   </td>
</tr>
</table>
</BODY>
</html>
