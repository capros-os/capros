<html>
<head>
<link rel=STYLESHEET HREF="../CSS/stylesheet.css" type="text/css">
<title>Layout of an EROS Domain</title>
</head>
<BODY BGCOLOR="#ffeedd" text="#000000" link="#0000ee" vlink="#551a8b" alink="#ff0000"><table><tr valign=top><td width="10%">&nbsp;</td><td><div class=nocss><br class=nocss>&nbsp;<br class=nocss>&nbsp;</div>
<center>
  <H1>Layout of an EROS Domain</H1>
</center>
  <div class=obsolete>
    <p>  <img src="../img/construction.gif" align=left>  The content
    of this note is now obsolete.  Current information can now be
    found on the <a
    href="../devel/ObRef/primary/Process.html">Process</a> page.
  </div>
<p> An EROS domain is made up of three nodes: the domain root, the
general registers node, and the key registers node.  There are three
kinds of constraints on the content layout of these nodes:
<ul>
  <li> Requirements for the domain to be well-formed.
  <li> Universal slot usage conventions, which apply to all
       architectures.
  <li> Slot usage conventions that apply to all 32-bit architectures.
  <li> Slot usage constraints that are specific to a particular
       implementation.
</ul>
<h2>1. Well-Formed Domains</h2> 
<p> In order to be <strong>well-formed</strong>, a domain must meet
the following constraints:
<ol>
  <li> 
       <p> The domain root node must have a read-write node key in slot
       14.  The node in this slot will act as the general registers
       node.
  <li> 
       <p> The domain root node must have a read-write node key in
       slot 15.  The node in this slot will act as the key registers
       node.
       <p> <em>Note 1:</em> we are contemplating a design change in
       which a zero number key would be permissable in slot 15 to
       reduce the overhead of rehosted programs, which neither send
       nor receive messages.  In the event that a zero number key was
       present and the domain was not marked as "foreign," the domain
       keeper would be invoked if a reference was made to the domain's
       key registers.
  <li>
       <p> The domain root node, general registers node, and key
       registers node (if present) must be distinct.
  <li> 
       <p> All keys in register slots must be number keys.  Register
       slots include all slots in the general registers node, and
       those slots in the domain root designated as holding register
       values, whether or not those slots are used by a particular
       architecture.
  <li> 
       <p> All keys in reserved slots must be zero number keys.
</ol>
<p> A domain is checked to verify that it is well-formed whenever an
operation is performed on a start key, resume key, or domain key.  If
the domain is discovered to be malformed, it is placed in a faulted
state, and will not execute instructions until corrective action is
taken.  If a valid keeper key is present, the keeper will be invoked
to inform it of the fault.
<h3>1.1 Non-Requirements:</h3>
<p> In spite of what you might reasonably expect, the following are
<em>not</em> required in order for a domain to be well-formed:
<ul>
  <li> <em>A valid address space key.</em> A domain without a valid
       address space key simply does not fetch instructions.
  <li> <em>A valid schedule key.</em> A domain without a valid
       schedule key simply does not fetch instructions.
  <li> <em>A valid keeper key.</em> The absence of a keeper key is
       only an issue when the domain takes a fault.  If no keeper can
       be notified, the domain simply becomes unable to execute
       instructions.
</ul>
<h2>2. Universal Slot Usage Conventions</h2> 
<p> All implementations impose the following usage constraints on the
slots in a domain root.  Slots shown as "reserved" must hold a zero
number key until these features are implemented.
<p>
<center>
  <table border width=90%>
    <caption>
      <strong>Domain Root</strong>
    </caption>
    <tr valign=top>
      <th align=left width=5%>
	Slot
      </th>
      <th align=left width=45%>
	Usage
      </th>
      <th align=left width=5%>
	Slot
      </th>
      <th align=left width=45%>
	Usage
      </th>
    </tr>
    <tr valign=top>
      <td>
	DR0
      </td>
      <td>
	Schedule Class key
      </td>
      <td>
	DR8
      </td>
      <td>
	<strong>Register slot</strong>
	<br> Bytes 0-3: order/return code
	<br> Bytes 4-7: invocation ctrl block
	<br> Bytes 8-11: Invoked key slot
      </td>
    </tr>
    <tr valign=top>
      <td>
	DR1
      </td>
      <td>
	Keeper key
      </td>
      <td>
	DR9
      </td>
      <td>
	<strong>Register slot</strong>
	<br> Bytes 0-3: PC
	<br> Bytes 4-7: SP
      </td>
    </tr>
    <tr valign=top>
      <td>
	DR2
      </td>
      <td>
	Address space key
      </td>
      <td>
	DR10
      </td>
      <td>
	<strong>Architecture Defined</strong>
      </td>
    </tr>
    <tr valign=top>
      <td>
	DR3
      </td>
      <td>
	<em>Reserved for Symbol table space key.</em>
      </td>
      <td>
	DR11
      </td>
      <td>
	<strong>Architecture Defined</strong>
      </td>
    </tr>
    <tr valign=top>
      <td>
	DR4
      </td>
      <td>
	Brand key
      </td>
      <td>
	DR12
      </td>
      <td>
	<strong>Architecture Defined</strong>
      </td>
    </tr>
    <tr valign=top>
      <td>
	DR5
      </td>
      <td>
	Number key providing trap code and associated information
      </td>
      <td>
	DR13
      </td>
      <td>
	<em>Reserved for alternate message buffer key.</em>
      </td>
    </tr>
    <tr valign=top>
      <td>
	DR6
      </td>
      <td>
	<strong>Register slot</strong>
	<br> Message receive descriptor.
      </td>
      <td>
	DR14
      </td>
      <td>
	General registers Node key
	<br>(if present)
      </td>
    </tr>
    <tr valign=top>
      <td>
	DR7
      </td>
      <td>
	<strong>Register slot</strong>
	<br> Message send descriptor
      </td>
      <td>
	DR15
      </td>
      <td>
	Key registers Node key
	<br>(if present)
      </td>
    </tr>
  </table>
</center>
<h3>2.1. Send and Receive Information</h3>
<p> The message send and receive information share a common structure
for nibbles 0 through 15. These nibbles are used as follows:
<p>
<center>
  <table border width=90%>
    <caption>
      <strong>Send and Receive Information Description</strong>
    </caption>
    <tr valign=top>
      <th align=left>
	Nibble
      </th>
      <th align=left>
	Meaning
      </th>
    </tr>
    <tr valign=top>
    <tr valign=top>
      <td>
	0-3
      </td>
      <td>
	Size of sent/received string buffer
      </td>
    </tr>
      <td>
	4
      </td>
      <td>
	Slot of 0th sent/received key
      </td>
    </tr>
    <tr valign=top>
      <td>
	5
      </td>
      <td>
	Slot of 1st sent/received key
      </td>
    </tr>
    <tr valign=top>
      <td>
	6
      </td>
      <td>
	Slot of 2nd sent/received key
      </td>
    </tr>
    <tr valign=top>
      <td>
	7
      </td>
      <td>
	Slot of 3rd sent/received key
      </td>
    </tr>
    <tr valign=top>
      <td>
	8-15
      </td>
      <td>
	Address of string send/receive buffer
      </td>
    </tr>
    <tr valign=top>
      <td>
	16-23
      </td>
      <td>
	Available for architecture-specific use
      </td>
    </tr>
  </table>
</center>
<p> Note that the send and receive information blocks correspond to
specific registers in the implementation architecture.  Two common
message cases are messages that pass no keys and messages that pass no
string. The layout of the send and receive information blocks is
designed to map neatly onto a 32-bit register set to minimize the
number of registers clobbered by the message mechanism in these cases.
<h3>2.2. Invocation Control Block</h3>
<p> Only the bottom three bytes of the invocation control block
register have defined values.  The remaining bytes must be zero.  The
invocation control block controls both the invocation and the send and
receive of message strings, and is layed out as follows:
<p>
<center>
  <table border width=90%>
    <caption>
      <strong>Invocation Control Information</strong>
    </caption>
    <tr valign=top>
      <th align=left>
	Nibble
      </th>
      <th align=left>
	Meaning
      </th>
    </tr>
    <tr valign=top>
      <td>
	0-3
      </td>
      <td>
	Key data (returned)
      </td>
    </tr>
    <tr valign=top>
      <td>
	4
      </td>
      <td>
	Send control block.  Values are:
	<table>
	  <tr>
	    <th align=left>
	      Value
	    </th>
	    <th align=left>
	      Meaning
	    </th>
	  </tr>
	  <tr valign=top>
	    <td>
	      0x0
	    </td>
	    <td>
	      Omit
	    </td>
	  </tr>
	  <tr valign=top>
	    <td>
	      0x1
	    </td>
	    <td>
	      Send from buffer
	    </td>
	  </tr>
<!-- 	  <tr valign=top> -->
<!-- 	    <td> -->
<!-- 	      0x2 -->
<!-- 	    </td> -->
<!-- 	    <td> -->
<!-- 	      Send from register -->
<!-- 	    </td> -->
<!-- 	  </tr> -->
	</table>
      </td>
    </tr>
    <tr valign=top>
      <td>
	5
      </td>
      <td>
	Receive control block.  Values are:
	<table>
	  <tr>
	    <th align=left>
	      Value
	    </th>
	    <th align=left>
	      Meaning
	    </th>
	  </tr>
	  <tr valign=top>
	    <td>
	      0x0
	    </td>
	    <td>
	      Omit
	    </td>
	  </tr>
	  <tr valign=top>
	    <td>
	      0x1
	    </td>
	    <td>
	      Receive to buffer
	    </td>
	  </tr>
<!-- 	  <tr valign=top> -->
<!-- 	    <td> -->
<!-- 	      0x2 -->
<!-- 	    </td> -->
<!-- 	    <td> -->
<!-- 	      Receive to register -->
<!-- 	    </td> -->
<!-- 	  </tr> -->
	</table>
      </td>
    </tr>
    <tr valign=top>
      <td>
	6
      </td>
      <td>
	Invocation type.  Values are:
	<table>
	  <tr>
	    <th align=left>
	      Value
	    </th>
	    <th align=left>
	      Meaning
	    </th>
	  </tr>
	  <tr valign=top>
	    <td>
	      0x0
	    </td>
	    <td>
	      Invocation is a <strong>reply</strong>
	    </td>
	  </tr>
	  <tr valign=top>
	    <td>
	      0x1
	    </td>
	    <td>
	      Invocation is a <strong>call</strong>
	    </td>
	  </tr>
	  <tr valign=top>
	    <td>
	      0x2
	    </td>
	    <td>
	      Invocation is a <strong>fork</strong>
	    </td>
	  </tr>
	  <tr valign=top>
	    <td>
	      <em>other</em>
	    </td>
	    <td>
	      Undefined
	    </td>
	  </tr>
	</table>
      </td>
    </tr>
    <tr valign=top>
      <td>
	7
      </td>
      <td>
	Zero
      </td>
    </tr>
  </table>
</center>
<h2>3. Common 32-bit Architecture Constraints</h2> 
<p> Slot 9 of the domain root is reserved in all 32-bit architectures
to contain the values of the PC and SP registers. This is to simplify
the construction of domain generation tools by keeping registers that
support concepts common to all 32-bit machines in common slots.  This,
on 32-bit architectures, the layout of this slot is as follows:
<p>
<center>
  <table border width=90%>
  <caption>
    <strong>Slot 9 Conventions</strong>
  </caption>
    <tr>
      <th align=left>
	Byte
      </th>
      <th align=left>
	Meaning
      </th>
    </tr>
    <tr>
      <td>
	0-3
      </td>
      <td>
	PC value
      </td>
    </tr>
    <tr>
      <td>
	4-7
      </td>
      <td>
	SP value
      </td>
    </tr>
    <tr>
      <td>
	8-11
      </td>
      <td>
	<em>Implementation defined</em>
      </td>
    </tr>
  </table>
</center>
<h2>4. i386/i486/Pentium Domain Layout</h2> 
<p> The following tables give the register layouts used on the i386
family of processors.  Layout inherited from above is included in
normal face, and machine-specific additions are is shown in
<strong>boldface</strong>.
<center>
  <table border width=90%>
    <caption>
      <strong>Domain Root</strong>
    </caption>
    <tr valign=top>
      <th align=left width=5%>
	Slot
      </th>
      <th align=left width=45%>
	Usage
      </th>
      <th align=left width=5%>
	Slot
      </th>
      <th align=left width=45%>
	Usage
      </th>
    </tr>
    <tr valign=top>
      <td>
	0
      </td>
      <td>
	Schedule key
      </td>
      <td>
	8
      </td>
      <td>
	<strong>Bytes 0-3: %eax</strong>
	<br> <strong>Bytes 4-7: %ebx</strong>
	<br> <strong>Bytes 8-9: %ebp</strong>
      </td>
    </tr>
    <tr valign=top>
      <td>
	1
      </td>
      <td>
	Keeper key
      </td>
      <td>
	9
      </td>
      <td>
	<strong>Bytes 0-3: %eip</strong>
	<br> <strong>Bytes 4-7: %esp</strong>
	<br> <strong>Bytes 8-9: %cs</strong>
	<br> <strong>Bytes 10-11: %ss</strong>
      </td>
    </tr>
    <tr valign=top>
      <td>
	2
      </td>
      <td>
	Address space key
      </td>
      <td>
	10
      </td>
      <td>
	<strong>Bytes 0-3: %EFLAGS</strong>
	<br> <strong>Bytes 4-7:</strong> <em>zero</em>
	<br> <strong>Bytes 8-11:</strong> <em>zero</em>
      </td>
    </tr>
    <tr valign=top>
      <td>
	3
      </td>
      <td>
	Zero number key
      </td>
      <td>
	11
      </td>
      <td>
	Zero number key
      </td>
    </tr>
    <tr valign=top>
      <td>
	4
      </td>
      <td>
	Brand key
      </td>
      <td>
	12
      </td>
      <td>
	Zero number key
      </td>
    </tr>
    <tr valign=top>
      <td>
	5
      </td>
      <td>
	Trap code
      </td>
      <td>
	13
      </td>
      <td>
	Zero number key
      </td>
    </tr>
    <tr valign=top>
      <td>
	6
      </td>
      <td>
	<strong>Bytes 0-3: %ecx</strong>
	<br> <strong>Bytes 4-7: %edi</strong>
	<br> <strong>Bytes 8-9: %ds</strong>
	<br> <strong>Bytes 10-11: %es</strong>
      </td>
      <td>
	14
      </td>
      <td>
	Gen regs node key
      </td>
    </tr>
    <tr valign=top>
      <td>
	7
      </td>
      <td>
	<strong>Bytes 0-3: %edx</strong>
	<br> <strong>Bytes 4-7: %esi</strong>
	<br> <strong>Bytes 8-9: %fs</strong>
	<br> <strong>Bytes 10-11: %gs</strong>
      </td>
      <td>
	15
      </td>
      <td>
	Key regs node key
      </td>
    </tr>
  </table>
</center>
<p> As it happens, all of the integer machine registers fit in the
domain root on the x86 family.  Registers associated with auxiliary
components, such as the floating point unit and the hardware debugging
registers are kept in the general registers node.  Whether to reload
the floating point registers can be determined by examining the bits
in the EFLAGS register.
<p> Given all of that, the layout of the general registers shown
below may make more sense.
<center>
  <table border width=90%>
    <caption>
      <strong>General Registers</strong>
    </caption>
    <tr valign=top>
      <th align=left width=5%>
	Slot
      </th>
      <th align=left width=45%>
	Usage
      </th>
      <th align=left width=5%>
	Slot
      </th>
      <th align=left width=45%>
	Usage
      </th>
    </tr>
    <tr valign=top>
      <td>
	0
      </td>
      <td>
	<strong>Bytes 0-3: %fdp</strong>
	<br><strong>Bytes 4-5: %fds</strong>
	<br><strong>Bytes 6-7: %ftag</strong>
	<br><strong>Bytes 8-9: %fstatus</strong>
	<br><strong>Bytes 10-11: %fctrl</strong>
      </td>
      <td>
	8
      </td>
      <td>
	<strong>Floating Reg 0</strong>
      </td>
    </tr>
    <tr valign=top>
      <td>
	1
      </td>
      <td>
	<strong>Bytes 0-3: %fip</strong>
	<br><strong>Bytes 4-5: %fcs</strong>
	<br><strong>Bytes 6-11:</strong> <em>zero</em>
      </td>
      <td>
	9
      </td>
      <td>
	<strong>Floating Reg 1</strong>
      </td>
    </tr>
    <tr valign=top>
      <td>
	2
      </td>
      <td>
	<strong>Zero number key</strong>
      </td>
      <td>
	10
      </td>
      <td>
	<strong>Floating Reg 2</strong>
      </td>
    </tr>
    <tr valign=top>
      <td>
	3
      </td>
      <td>
	<strong>Zero number key</strong>
      </td>
      <td>
	11
      </td>
      <td>
	<strong>Floating Reg 3</strong>
      </td>
    </tr>
    <tr valign=top>
      <td>
	4
      </td>
      <td>
	<strong>Zero number key</strong>
      </td>
      <td>
	12
      </td>
      <td>
	<strong>Floating Reg 4</strong>
      </td>
    </tr>
    <tr valign=top>
      <td>
	5
      </td>
      <td>
	<strong>Zero number key</strong>
      </td>
      <td>
	13
      </td>
      <td>
	<strong>Floating Reg 5</strong>
      </td>
    </tr>
    <tr valign=top>
      <td>
	6
      </td>
      <td>
	<strong>Zero number key</strong>
      </td>
      <td>
	14
      </td>
      <td>
	<strong>Floating Reg 6</strong>
      </td>
    </tr>
    <tr valign=top>
      <td>
	7
      </td>
      <td>
	<strong>Zero number key</strong>
      </td>
      <td>
	15
      </td>
      <td>
	<strong>Floating Reg 7</strong>
      </td>
    </tr>
  </table>
</center>
<hr>
<em>Copyright 1998 by Jonathan Shapiro.  All rights reserved.  For terms of 
redistribution, see the 
<a href="../legal/license/GPL.html">GNU General Public License</a></em>
</td><td width="10%">&nbsp;</td></tr></table></BODY>
</html>
