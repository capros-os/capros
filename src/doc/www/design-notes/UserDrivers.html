<html>
  <head>
    <title>Persistence, Non-persistence, and Device Drivers</title>
  </head>
  <BODY BGCOLOR="#fff0ff" text="#000000" link="#0000ee" vlink="#551a8b" alink="#ff0000">
  <center>
    <h1 class="title">Persistence, Non-persistence, and Device Drivers</h1>
  </center>
    <h1>Device Drivers</h1>
    <p>
       The ability to port drivers from Linux is very important, because
       there are very many drivers. The ability to port them with
       minimal changes is important because they have a high rate of change. 
    </p>
    <p>
      Device drivers, in most cases, have the same security properties
      as the kernel - they must be trusted by everyone,
      because they direct hardware that has write access to all
      of physical memory. 
      In KeyKOS and early versions of EROS, device drivers executed
      as part of the kernel. 
    </p>
    <p>
      However, there are several advantages to having drivers execute
      in user processes:
    </p>
    <ul>
    <li>
      User mode provides some protection from accidental damage. 
    </li>
    <li>
      To port drivers from Linux with a minimum of rewriting, you need to
      run them in an environment that looks like the Linux kernel
      (with, for example, a per-process stack). 
      Building such an environment is, like most everything, easier
      in processes than in the kernel. 
    </li>
    <li>
      If a GPL-licensed driver is linked with the kernel, 
      there is an argument that the kernel is at risk of being considered
      a derived work of the driver and therefore subject to GPL.
      Placing the driver in a user-mode process reduces this risk.
    </li>
    </ul>
    <p>
      On the other hand, there is a performance cost in putting drivers
      outside the kernel, as there is for most code. 
      But today, virtually all devices are architected in a way
      (such as using DMA) that 
      does not place a high penalty on user-mode drivers .
      See <a href="http://www.coyotos.org/pipermail/coyotos-dev/2005-October/000181.html">
      this email thread</a> for a discussion of this.
    </p>
    <p>
      Therefore in CapROS virtually all drivers will run in user processes. 
    </p>
    <h1>Persistence and Non-Persistence</h1>
    <p>
      The CapROS model is that all user data and capabilities are persistent,
      meaning their state is preserved even when the system is rebooted.
      This assures that the security state (the state of the capabilities)
      is valid and consistent. 
      Persistence is accomplished by checkpointing the state to disk
      (or other nonvolatile storage). 
      The difficulty arises because the disk driver is part of the user state. 
    </p>
    <p>
      The solution is to exempt drivers from the persistence contract.
      Several reasons motivate this:
    </p>
    <ul>
    <li>
      The disk driver cannot load itself, so it must be loaded by the
      boot loader. 
      Available boot loaders can't decipher the checkpoint log
      to find the correct version of the data to load. 
    </li>
    <li>
      It is awkwared, though theoretically possible,
      for the disk driver to checkpoint itself.
      At a checkpoint, we would do copy-on-write of the driver data
      (this logic already exists). 
      It would be necessary to ensure that enough available memory
      exists to do all the copies in memory. 
      Making the disk driver non-persistent removes this constraint. 
    </li>
    <li>
      There is little reason for drivers to be persistent,
      because on reboot the device state is either reset or unknown.
      Drivers could in theory use something like the KeyKOS journaling
      mechanism to remember the device state, but this mechanism
      is generally better applied at a higher level. 
    </li>
    </ul>
    <p>
      Most of these reasons apply specifically to disk drivers,
      but since disks can be attached
      via most any bus or network, the reasons apply to all those drivers too.
    </p>
    <p>
      Therefore, all device drivers will be non-persistent. 
      They will live in OID ranges that are marked as such.
      These ranges will be loaded by the boot loader
      (in GRUB, they are considered to be "modules") 
      and pinned so they cannot be removed from memory. 
      Drivers will of course be granted whatever
      privileges are needed to to their job (this is architecture-dependent). 
      The DevicePrivs key allows drivers to field interrupts. 
      The DevicePrivs key will also make it possible for a driver
      to obtain contiguous physical memory for use with DMA. 
    </p>
    <p>
      Now the difficulty is, what is the consistency contract between
      the persistent and non-persistent worlds? For example, we want
      to avoid the following scenario:
    </p>
    <ol>
    <li>
      A persistent user process P calls a driver. The driver receives a 
      resume key to P.
    </li>
    <li>
      A checkpoint is taken and a restart occurs. Because the driver is
      non-persistent, it reverts to its initial state
      and loses the resume key. It never returns to process P. 
    </li>
    </ol>
    <p>
      Here is the design for the interaction of the persistent and
      non-persistent worlds. 
    </p>
    <ul>
    <li>
      Persistent processes may call non-persisten processes, and
      non-persistent nodes may hold capabilities to persistent objects. 
      When a checkpoint is taken, the non-persistent nodes are examined.
      Any resume keys found there to persistent processes
      will cause the target process to be
      treated as though it had not yet executed its call.
      Thus on a restart the persistent process will run and reexecute its call. 
      OR, the target process will be checkpointed with a state
      such that on restart it will run as though the call returned an error. 
    </li>
    <li>
      Non-persistent nodes are initialized with no capabilities to
    <li>
      Persistent nodes may hold capabilities to non-persistent objects.
      It is the responsibility of the non-persistent world to make sure
      that the only capabilities that can find their way to the
      non-persistent world are ones whose authority does not change
      on a restart from checkpoint - namely, start keys to the
      "front door" of a driver. [Be more precise.]
    </li>
    </ul>
    <p>
      It remains to be seen how this will play out.
      Note that a device driver could have a persistent part and
      a non-persistent part (but that may make porting more difficult).
      The only requirement is that
      any part used by the kernel for paging must be non-persistent. 
    </p>
    <p>
      The interface between the kernel and the disk driver(s)
      has yet to be designed, but should be straightforward. 
    </p>
  <hr>
<table>
<tr valign=top>
  <td width=92>
<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=132228&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
  </td>
  <td>
      <em>Copyright 2006 by Strawberry Development Group.  All rights reserved.
      For terms of redistribution, see the <a
      href="./legal/license/GPL.html">GNU General Public License</a></em>
   </td>
</tr>
</table>
  </body>
</html>
