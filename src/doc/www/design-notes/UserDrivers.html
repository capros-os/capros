<html>
  <head>
    <title>Persistence, Non-persistence, and Device Drivers</title>
  </head>
  <BODY BGCOLOR="#fff0ff" text="#000000" link="#0000ee" vlink="#551a8b" alink="#ff0000">
  <center>
    <h1 class="title">Persistence, Non-persistence, and Device Drivers</h1>
  </center>
    <h1>Device Drivers</h1>
    <p>
       The ability to port drivers from Linux is very important, because
       there are very many drivers. The ability to port them with
       minimal changes is important because they are said to have
       a high rate of change. 
    </p>
    <p>
      Device drivers, in most cases, have the same security properties
      as the kernel - they must be trusted by everyone,
      because they direct hardware that on most architectures
      has write access to all of physical memory. 
      In KeyKOS and early versions of EROS, device drivers executed
      as part of the kernel. 
    </p>
    <p>
      However, there are several advantages to having drivers execute
      in user processes:
    </p>
    <ul>
    <li>
      It's easier to write a program to run in user mode than in the kernel.
    </li>
    <li>
      User mode provides some protection from accidental damage. 
    </li>
    <li>
      To port drivers from Linux with a minimum of rewriting, you need to
      run them in an environment that looks like the Linux kernel
      (with, for example, a per-process stack). 
      Building such an environment is, like most everything, easier
      in processes than in the kernel. 
    </li>
    <li>
      If a GPL-licensed driver is linked with the kernel, 
      there is an argument that the kernel is at risk of being considered
      a derived work of the driver and therefore subject to GPL.
      Placing the driver in a user-mode process reduces this risk.
    </li>
    </ul>
    <p>
      There are also some disadvantages:
    </p>
    <ul>
    <li>
      There is a performance cost in putting drivers
      outside the kernel, as there is for most code. 
      But today, virtually all devices are architected in a way
      (such as using DMA) that 
      does not place a high penalty on user-mode drivers .
      See <a href="http://www.coyotos.org/pipermail/coyotos-dev/2005-October/000181.html">
      this email thread</a> for a discussion of this.
    </li>
    <li>
      Linux drivers are already designed to run in a kernel;
      running them in a user process is an additional change required
      to port them. 
    </li>
    </ul>
    <p>
      The decision in CapROS is to run virtually all drivers in user processes. 
    </p>
    <p>
      Drivers will of course be granted whatever
      privileges are needed to do their job (this is architecture-dependent). 
      The DevicePrivs key allows drivers to field interrupts
      and (together with a Range key) access memory containing device registers.
      The DevicePrivs key will also make it possible for a driver
      to obtain contiguous physical memory for use with DMA. 
    </p>
    <h1>Page Fault Handler</h1>
    <p>
      The Page Fault Handler (PFH) is defined as all the user objects which 
      could be needed to service requests (from the kernel) to fetch and
      write pages and nodes from or to backing store. This includes
      the process that fields those requests,
      any other processes that service those requests,
      the process(es) that service backing store device interrupts,
      all the code and data used by those processes,
      and any other pages and nodes used by those processes. 
    </p>
    <p>
      Backing store is usually disk, but the PFH is not exactly the same
      as the disk driver. The PFH includes any objects used to handle
      the buses by which the backing store is accessed, such as PCI,
      USB, Firewire, or even Ethernet. The PFH excludes any part of the
      disk driver that is used to service user requests (for example,
      querying statistics) but not used to service kernel requests. 
    </p>
    <p>
    </p>
    <h1>Persistence and Non-Persistence</h1>
    <p>
      The CapROS model is that user data and capabilities are persistent,
      meaning their state is preserved even when the system is rebooted.
      Persistence is accomplished by checkpointing the state to 
      nonvolatile backing storage. 
      By checkpointing all user state, we
      assure that the security state (the state of the capabilities)
      is valid and consistent. 
    </p>
    <p>
      The problem is that the PFH, though part of the user state, 
      cannot be persistent, for several reasons:
    </p>
    <ul>
    <li>
      The PFH obviously cannot load itself, so it must be loaded by the
      boot loader. 
      Available boot loaders can't decipher the checkpoint log
      to find the correct version of the data to load. 
    </li>
    <li>
      It is awkward, though theoretically possible,
      for the PFH to checkpoint itself.
      At a checkpoint, we would do copy-on-write of the PFH data
      (this logic will exist anyway). 
      It would be necessary to ensure that enough available memory
      exists to do all the copies in memory. 
      Making the PFH non-persistent removes this constraint. 
    </li>
    <li>
      There is little reason for the PFH (or other drivers for that matter)
      to be persistent,
      because on reboot the device state is either reset or unknown.
      Drivers could in theory use something like the KeyKOS journaling
      mechanism to remember the device state, but this mechanism
      is generally better applied at a higher level. 
    </li>
    </ul>
    <p>
      Therefore, we must declare that some user state is non-persistent. 
      Non-persistent objects will live in OID ranges that are marked as such.
      These ranges will be loaded by the boot loader
      (in GRUB, they are considered to be "modules").
      Non-persistent objects must never be cleaned, checkpointed, or written
      back to disk. 
      They must never be removed from memory. 
      (It may prove useful to allow non-persistent objects to be
      <i>explicitly</i> released from memory, after a configuration
      procedure has determined they are not needed.) 
    </p>
    <h2>Classes of Objects</h2>
    <p>
      We can now identify four different classes of objects:
    </p>
<ol>
<li>
The PFH, which is non-persistent.
</li>
<li>
Non-persistent objects other than the PFH.
We want to limit the number of non-persistent objects, if only because
they cannot be paged out, but will probably put all device drivers
(other than the PFH) in this class just for consistency.
</li>
<li>
Persistent objects that are pinned (locked in memory).
We want to limit the number of pinned objects because they use
physical memory which is a limited resource. 
Persistent objects may need to be pinned if they are referenced by the PFH.
</li>
<li>
Persistent objects that are not pinned.
All normal user objects fall into this class.
</li>
</ol>
    <p>
      Note that objects move between classes 3 and 4 as they are
      pinned and unpinned. 
      And an object in class 2 effectively moves to class 1 while
      it holds a lock that is also used by the PFH. 
    </p>
    <p>
      Also note that if the system is configured as a
      diskless or "embedded" system, the entire system is non-persistent. 
      Such systems need not be considered further here.
    </p>
<h1>Consistency</h1>
    <p>
      We said above that the system takes checkpoints to ensure
      the consistency (including security) of the user data.
      Now the question is, what is the consistency contract between
      the persistent and non-persistent worlds? For example, we want
      to avoid scenarios such as the following :
    </p>
    <ol>
    <li>
      A persistent user process P calls a driver. The driver receives a 
      resume key to P.
    </li>
    <li>
      A checkpoint is taken and a restart occurs. Because the driver is
      non-persistent, it reverts to its initial state
      and loses the resume key. It never returns to process P. 
    </li>
    </ol>
    <h2>Capability Sharing</h2>
    <p>
      Here are the design constraints for the interaction of the four
      classes of objects.
    </p>
    <h3>Deadlock</h3>
    <p>
      The PFH must never reference unpinned objects, because that
      would lead to a deadlock. 
      (It is permissible to have a capability to such an object,
      as long as it is never used.)
    </p>
    <p>
      This prohibition applies even to resume keys, since the designated
      process could be paged out when the key is received, or could become
      paged out while the key is held. 
      An unpinned process should not CALL a start key to the PFH,
      because the PFH must not receive and use the resume key. 
    </p>
    <p>
      In the case of a gate key,
      both the process and the buffer that receives the string
      must be pinned, so a message can be sent to the key. 
    </p>
    <p>
      More generally, the PFH could be designed to handle its own faults
      recursively. There needs to be some limit on the depth of recursion.
      For simplicity, we will design with no recursion. 
    </p>
    <p>
      Another constraint applies to locks (such as semaphores, mutexes,
      or spinlocks) that are used by the PFH. 
      A process must not reference unpinned objects
      while holding such a lock.
    </p>
    <h3>Reset</h3>
    <p>
      We assume that non-persistent objects are initialized with no
      capabilities to persistent objects. Given that, when the system restarts,
      any keys to persistent objects held by non-persistent objects
      will be lost. This should not be a problem for the 
      non-persistent object, because it will be initialized to
      a consistent state. However, a persistent object that expected
      to be invoked will wait forever. 
    </p>
    <p>
      We will solve this problem for resume keys. When the system
      takes a checkpoint, it will examine all non-persistent nodes. 
      For each resume key it finds, it will save the state of the
      waiting process such that if restarted from that state,
      the process will run and re-execute its CALL invocation. 
    </p>
    <p>
      In that case, the operation that was requested by the CALL
      invocation may have partially completed before the last checkpoint,
      and partially or fully completed after the last checkpoint and
      before the restart.
      This behavior is unavoidable, because the system cannot in general
      checkpoint and roll back the state of I/O devices. 
      Programs that invoke I/O devices must be prepared to cope with
      this possibility. 
      In some cases, the driver can respond to the re-executed CALL
      by saying "the device is not now known to be in a state
      where you can perform that request (for example, not "open"). 
    </p>
    <p>
      Any keys other than resume keys will be dropped on restart.
      Start keys should not be held, and other keys are probably not
      a problem. 
      As for security, it should be clear that dropping capabilities
      does not open any vulnerabilities. 
    </p>
    <p>
      Non-persistent objects could be initialized with capabilities to
      persistent objects, but they must somehow arrange for the objects
      to be fetched and pinned before using the capabilities,
      and they must cope with the reset issue.
      It seems better to avoid this situation.
    </p>
    <h3>Time Travel</h3>
    <p>
      Persistent objects may hold capabilities to non-persistent objects.
      It is the responsibility of the non-persistent world to control
      the capabilities that can find their way to the
      persistent world.
      Such capabilities should be designed with the awareness that
      the non-persistent state is not checkpointed and will be reset
      when the system is restarted.
      From the point of view of the persistent object,
      the non-persistent objects appear to travel backwards in time
      to their initial state. 
    </p>
    <p>
      A persistent process may hold and call a start key to an object
      in class 2, provided it has no assumptions about the state
      of the object. 
    </p>
    <p>
      Clearly a resume key to a non-persistent process suffers from
      the time travel problem.
    </p>
    <p>
      A memory key to a non-persistent segment may be used for two-way
      communication, with a protocol that allows the persistent user
      to discover when the non-persistent state has been reset. 
      Atomic operations can be used to make consistent updates,
      but I don't think locks will work across the persistence boundary.
    </p>
    <p>
      If a key to a non-persistent object is held by a persistent process,
      you should not delete the non-persistent object or revoke the key,
      because such actions will be undone by time travel.
    </p>
    <p>
      There could be some type of rendezvous object that the user and
      driver use to pass messages.
      When both (1) the driver has called to receive a message,
      and (2) the user has called to send a message, the message is delivered.
      (This is a bit like a Coyotos Endpoint, but the message is 
      restricted; no keys can be passed.) 
      The rendezvous object would be considered non-persistent. 
    </p>
    <h1>Communication</h1>
    <p>
      With such severe limitations on the connections between the persistent
      and non-persistent worlds, one may wonder just how to accomplish
      necessary communication. Here are some design ideas. 
    </p>
    <p>
      A device driver could be divided into different parts,
      each in a different one of the four classes of objects. 
      In many cases a driver will need a persistent front end that presents
      a more usable interface to clients, and can handle multiple
      independent clients. 
      The only requirement is that any part used by the kernel for paging
      is part of the PFH and therefore must be non-persistent. 
    </p>
    <p>
      Perhaps the simplest design is to have a part of the driver
      in class 2 that is the user interface, and the rest in class 1
      acting as a server for both the class 2 part and the kernel. 
      The user interface can pin (and unpin) user objects if it is necessary
      for the class 1 part to access them. 
    </p>
    <p>
      Another design issue concerns protection boundaries. 
      Class 3 objects have more authority than class 4 (because they can
      pin), and class 2 have more than class 3 (because they can
      cause time travel). We want to keep different authorities in
      different processes, and use gate keys to transfer control
      between them. For efficiency, we want to avoid the need for
      one gate jump from 4 to 3, and a second jump from 3 to 2. 
      (And possibly more from 2 to 1.) 
      In other words, we want to traverse the most authority change
      with the fewest gate jumps. 
      From class 4, we cannot call class 1, so calling class 2
      makes sense. 
    </p>
    <p>
      Here is an older design:
      A persistent client process (or front end) could fork
      to a start key to a driver
      with a message that says, for example, "Start reading from location x". 
      Then the client process does some operation (to be designed)
      that waits for completion.
      (Compare with the Linux "wait queue".) 
      When the read completes, the driver causes the process to be restarted.
      No data can be sent to the client at this time, because 
      the client may have been paged out. Instead, the driver places results
      in a (nonpersistent) shared segment. 
      The client then re-executes its wait operation, which notes that
      the operation is completed and returns immediately.
      The client then looks in the shared segment for any results. 
    </p>
    <p>
      Note that restarting a client process that is waiting on a wait queue
      is safe, because while waiting there is an Activity structure for the
      process that is memory-resident.
      ("Activity" is the name of the kernel structure that tracks
      processes in the Running state.)
      The Activity structure is
      sufficient to page in the rest of the process. 
      In contrast, when a process has called another process, only the
      resume capability is left, and the invoker of the resume capability
      is responsible for paging in the process. 
    </p>
    <p>
      When a persistent client and a non-persistent driver
      are in communication,
      it is important to be able to upgrade one or the other while
      maintaining the communication. 
      Since the non-persistent world has no capabilities to the
      persistent world, upgrading a persistent client is no more
      difficult than upgrading any other persistent object. 
      To upgrade a non-persistent driver, here is one strategy.
      Create a new non-persistent disk range and install the new
      driver in it. Give the client the keys to the new driver and 
      instruct it to start using them when it next discovers that 
      the system is rebooted. 
      Overwrite the old driver on disk, so it will not operate in conflict
      with the new driver.
      Then reboot the system. 
    </p>
    <h1>Linux Userspace I/O drivers</h1>
    <p>
      Support for device drivers in user processes 
      was added to the Linux kernel in version 2.6.23-rc4 (drivers/uio). 
      We took a quick look at this feature and discovered the following:
    </p>
    <ul>
    <li>
      A small amount of code is still needed in the kernel to register
      and unregister the device. 
      An interrupt handler is also needed; it need do nothing more than
      disable further interrupts before the user process is notified
      of the interrupt via a signal (SIGIO). (Clearly, in CapROS it
      is also necessary to prevent continuous interrupts,
      because user processes run with interrupts enabled,
      but on some architectures it may be possible to accomplish this
      with an interrupt controller that has no device-specific knowledge.) 
    <p>
      Apparently kernel code is also needed to support open, release,
      and mmap.
    </p>
    </li>
    <li>
      This interface doesn't seem to change the Linux driver model
      in any substantial way. 
      Because there are few (or none) device drivers using this interface
      at this point, it is largely irrelevant from the standpoint of porting
      drivers to CapROS. 
    </li>
    <li>
      A motivation for this feature was to support device drivers
      with licenses more restrictive than GPL. This hardly helps us
      obtain drivers for CapROS. 
    </li>
    </ul>
    <h1>Paging</h1>
    <p>
      The interface between the kernel and the disk driver(s)
      has yet to be fully designed, but should be straightforward.
      For paging in,
      the driver periodically calls a special key to learn of any OIDs
      (object identifiers)
      that need to be fetched. The driver also receives a handle for
      the Activity that needs to be awakened when the OID is available. 
      This handle could be a special key that the driver invokes
      when it is done. 
      Alternatively, the kernel could enqueue the Activity on a wait queue
      based on a hash of the OID,
      and when done the driver could instruct the kernel
      to wake up that queue. 
    </p>
  <hr>
<table>
<tr valign=top>
  <td width=92>
<a href="http://sourceforge.net"><img src="http://sourceforge.net/sflogo.php?group_id=132228&amp;type=1" width="88" height="31" border="0" alt="SourceForge.net Logo" /></a>
  </td>
  <td>
      <em>Copyright 2006, 2007 by Strawberry Development Group.
      All rights reserved.
      For terms of redistribution, see the <a
      href="./legal/license/GPL.html">GNU General Public License</a></em>
This material is based upon work supported by the US Defense Advanced
Research Projects Agency under Contract No. W31P4Q-07-C-0070.
Approved for public release, distribution unlimited.
   </td>
</tr>
</table>
  </body>
</html>
