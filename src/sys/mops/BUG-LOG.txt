This is an attempt to log the flaws found using MOPS for later
reference in a paper. I'm also going to make note of bug implications
where possible.

(date unknown, circa March 2003, MOPS pre2)

  First attempt to run a check for "Yield Or Commit". The first
  version of the analysis did NOT check for yields after commits.
  This check found three places where commits had unintentionally been
  omitted. It probably would have found more, but once we saw
  that it worked shap tried to augment the test case to check for the
  yield after commit bug and we ran into a MOPS I/O speed limitation.

(date unknown, circa April 2003, MOPS pre3)

  Faster version of mops that uses binary files (though still not fast
  enough). We now ran the augmented check that looks for yield after
  commit and found a serious bug: the Range Key calls malloc() after
  COMMIT_POINT(), and malloc can conditionally yield.  This bug is
  actually quite bad for reasons explained shortly. Further mops
  checking was halted at this point because shap got distracted and
  the malloc() thing required some real thought.

  The problem with malloc() is that it can Yield() in the following
  case:

  This leads to a problem: malloc()'d storage MUST be allocated before
  the COMMIT_POINT(), but if a yield occurs in a second (or third, or
  ...) call to malloc() it isn't easy to clean up the dangling
  pointers left by the earlier malloc() calls.

  In actual practice, malloc() should not fail. The only path in which
  it is called following initialization is in the PublishMem call,
  which is used by device drivers to inform the kernel about the
  existence of physical memory ranges which the kernel was unable to
  autodetect (because the kernel does not contain device
  drivers). When PublishMem is called, the kernel performs a malloc()
  to allocate the ObjectHeader array corresponding to the new memory
  region.

  We don't want to preallocate "spare" ObjectHeader slots for these
  frames, because the ObjectHeader vectors are fairly large and there
  isn't any good way to predict how many we need.

  The malloc() in this case is coming out of the kernel heap, which
  may be unbacked at the time of the call to malloc(). Malloc()
  responds by stealing page frames out of the page cache in order to
  provide backing store for the kernel heap. Thereafter, these page
  frames will not be returned to the page cache.

  The difficulty is that the frame theft logic may need to clean the
  frame, and this may in turn cause queueing.

May 14, 2003, mops pre4:

  NOTE: We need a distinguished meta-AST that matches "whatever
  function was passed to us as 'main'" so that we can match
  termination conditions.

  Resumed our hunt for missing commits and yields after commits.

