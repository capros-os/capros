/*
 * Copyright (C) 1998, 1999, Jonathan S. Shapiro.
 * Copyright (C) 2005, Strawberry Development Group.
 *
 * This file is part of the EROS Operating System.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2,
 * or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

#include <kerninc/kernel.h>
#include <kerninc/IRQ.h>
#include <kerninc/Activity.h>
/*#include <kerninc/util.h>*/
#include <kerninc/Debug.h>
#include <kerninc/SysTimer.h>
/*#include <kerninc/Task.h>*/
#include <kerninc/Process.h>
#include <eros/i486/io.h>
#include "lostart.h"
#include "IDT.h"
#include "GDT.h"

/* #define TIMING_DEBUG */

/* #define INTRDEBUG */

/* EROS IDT has null, code, data/stack, TSS */
#define IDT_SIZE (IDT_ENTRIES * 8)
#define IDT_CODE_ENTRY 0x8
#define IDT_DATA_ENTRY 0x10
#define IDT_STACK_ENTRY 0x10

/* The gate interrupt number should not be zero, because
 * distinguishing it from divide-by-zero is too hard. There are just
 * too many things that show up with an exception code of zero. It
 * probably should be greater than 0x2f, so as to guarantee that it
 * will not collide with any hardware-generated interrupts.  While it
 * is possible to detect that an interrupt <= 0x2f was generated by an
 * INT instruction, it is hard enough that we want to avoid it on the
 * key invocation path.
 * 
 */

/*class IDT IDT;*/

/*extern "C" {*/
  extern void istub0x00(void);
  extern void istub0x01(void);
  extern void istub0x02(void);
  extern void istub0x03(void);
  extern void istub0x04(void);
  extern void istub0x05(void);
  extern void istub0x06(void);
  extern void istub0x07(void);
  extern void istub0x08(void);
  extern void istub0x09(void);
  extern void istub0x0a(void);
  extern void istub0x0b(void);
  extern void istub0x0c(void);
  extern void istub0x0d(void);
  extern void istub0x0e(void);
  extern void istub0x0f(void);
  extern void istub0x10(void);
  extern void istub0x11(void);
  extern void istub0x12(void);
  extern void istub0x13(void);
  extern void istub0x14(void);
  extern void istub0x15(void);
  extern void istub0x16(void);
  extern void istub0x17(void);
  extern void istub0x18(void);
  extern void istub0x19(void);
  extern void istub0x1a(void);
  extern void istub0x1b(void);
  extern void istub0x1c(void);
  extern void istub0x1d(void);
  extern void istub0x1e(void);
  extern void istub0x1f(void);
  extern void intr_clock(void);
  extern void istub0x21(void);
  extern void istub0x22(void);
  extern void istub0x23(void);
  extern void istub0x24(void);
  extern void istub0x25(void);
  extern void istub0x26(void);
  extern void istub0x27(void);
  extern void istub0x28(void);
  extern void istub0x29(void);
  extern void istub0x2a(void);
  extern void istub0x2b(void);
  extern void istub0x2c(void);
  extern void istub0x2d(void);
  extern void istub0x2e(void);
  extern void istub0x2f(void);
  extern void istub0x30(void);	/* first purely software interrupt */
  extern void intr_InvokeKey(void);	/* key invocation interrupt */
  extern void intr_CapInstr(void);	/* kernel-emulated instructions */
/*}*/

/* Stashing the bindings in a table is slightly more space efficient
 * than initializing them explicitly:
 */
struct {
  void (*stub)(void);
  bool allowUser;
} IntStub[IDT_ENTRIES] = {
  { istub0x00, false },
  { istub0x01, false },
  { istub0x02, false },
  { istub0x03, true },
  { istub0x04, true },
  { istub0x05, true },
  { istub0x06, false },
  { istub0x07, false },
  { istub0x08, false },
  { istub0x09, false },
  { istub0x0a, false },
  { istub0x0b, false },
  { istub0x0c, false },
  { istub0x0d, false },
  { istub0x0e, false },
  { istub0x0f, false },
  { istub0x10, false },
  { istub0x11, false },
  { istub0x12, false },
  { istub0x13, false },
  { istub0x14, false },
  { istub0x15, false },
  { istub0x16, false },
  { istub0x17, false },
  { istub0x18, false },
  { istub0x19, false },
  { istub0x1a, false },
  { istub0x1b, false },
  { istub0x1c, false },
  { istub0x1d, false },
  { istub0x1e, false },
  { istub0x1f, false },
  { intr_clock, false },
  { istub0x21, false },
  { istub0x22, false },
  { istub0x23, false },
  { istub0x24, false },
  { istub0x25, false },
  { istub0x26, false },
  { istub0x27, false },
  { istub0x28, false },
  { istub0x29, false },
  { istub0x2a, false },
  { istub0x2b, false },
  { istub0x2c, false },
  { istub0x2d, false },
  { istub0x2e, false },
  { istub0x2f, false },
  { istub0x30, false },		/* voluntary yield */
  { intr_InvokeKey, true  },	/* key invocation interrupt */
  { intr_CapInstr, true  }	/* kernel-emulated instructions */
};

GateDescriptor IdtTable[IDT_ENTRIES];

/* *** INLINE FUNCTIONS FIRST */


void
idt_SetEntry(int entry, void (*procPtr)(void), bool allowUser)
{
  uint32_t wProcPtr = (uint32_t) procPtr;

  IdtTable[entry].loOffset = (uint16_t) wProcPtr;
  IdtTable[entry].selector = sel_KernelCode;
  IdtTable[entry].zero = 0;
  IdtTable[entry].type = 0xeu;
  IdtTable[entry].system = 0;
  /* Use RPL==1 for non-user so kernel threads can call them. */
  IdtTable[entry].dpl = allowUser ? 3 : 1;
  IdtTable[entry].present = 1;
  IdtTable[entry].hiOffset = (uint16_t) (wProcPtr >> 16);
}


/* Moving this to IPC-vars has no appreciable impact. */
VecFn IntVecEntry[IDT_ENTRIES];

uint32_t IDTdescriptor[2];

extern void DivZeroFault(savearea_t *sa);
extern void DebugException(savearea_t *sa);
extern void BptTrap(savearea_t *sa);
extern void OverflowTrap(savearea_t *sa);
extern void BoundsFault(savearea_t *sa);
extern void BadOpcode(savearea_t *sa);
extern void DeviceNotAvailException(savearea_t *sa);
extern void InvalTSSFault(savearea_t *sa);
extern void SegNotPresFault(savearea_t *sa);
extern void SSFault(savearea_t *sa);
extern void GPFault(savearea_t *sa);
extern void PageFault(savearea_t *sa);
extern void CoprocErrorFault(savearea_t *sa);
extern void AlignCheckFault(savearea_t *sa);
extern void SIMDFloatingPointFault(savearea_t *sa);
extern void PseudoInstrException(savearea_t *sa);
extern void ReservedException(savearea_t *sa);

/* Note that the IDT gets set up immediately following the GDT, modulo
 * possibly being rounded up to an 8 byte boundary.  This causes them
 * both to live on the same page, which allows us to move them around
 * to get out of the way of the running domain as necessary.
 */

void
idt_Init()
{
  uint32_t widt;
  uint32_t vec;
  int i;

  /* Wire up IDT entries and set up to handle unbound vectors: */
  for (vec = 0; vec < IDT_ENTRIES; vec++) {
    IdtTable[vec].present = 0;
    idt_WireVector(vec, idt_UnboundVector);
    idt_SetEntry(vec, IntStub[vec].stub, IntStub[vec].allowUser);
  }
  
  /* Now set up to handle interrupts: */
 
  for (vec = iv_IRQ0; vec <= iv_IRQ15; vec++)
    idt_WireVector(vec, irq_UnboundInterrupt);

  /* Hand-wire the processor-generated exceptions: */
  idt_WireVector(iv_DivZero, DivZeroFault);
  idt_WireVector(iv_Debug, DebugException);
  idt_WireVector(iv_BreakPoint, BptTrap);
  idt_WireVector(iv_Overflow, OverflowTrap);
  idt_WireVector(iv_Bounds, BoundsFault);
  idt_WireVector(iv_BadOpcode, BadOpcode);
  idt_WireVector(iv_DeviceNotAvail, DeviceNotAvailException);
  idt_WireVector(iv_InvalTSS, InvalTSSFault);
  idt_WireVector(iv_SegNotPresent, SegNotPresFault);
  idt_WireVector(iv_StackSeg, SSFault);
  idt_WireVector(iv_GeneralProtection, GPFault);
  idt_WireVector(iv_PageFault, PageFault);
  idt_WireVector(iv_CoprocError, CoprocErrorFault);
  idt_WireVector(iv_AlignCheck, AlignCheckFault);
  idt_WireVector(iv_SIMDFloatingPoint, SIMDFloatingPointFault);
   
  /* Hand-wire the software interrupts: */
  idt_WireVector(iv_Yield, idt_YieldVector);
  idt_WireVector(iv_EmulPseudoInstr, PseudoInstrException);
#if 0
  /* This path no longer comes through here... */
  idt_WireVector(iv_InvokeKey, Invoke);
#endif


  idt_WireVector((intVecType) 0xf, ReservedException);
  for (i = 0x14; i <= 0x1f; i++)
    idt_WireVector((intVecType) i, ReservedException);
  
  idt_SetupInterruptControllers();
  
  widt = KVTOL(VtoKVA(IdtTable));
	
  IDTdescriptor[0] = IDT_SIZE | ((widt & 0xffff) << 16);
  IDTdescriptor[1] = widt >> 16;

  idt_lidt();
}



void
idt_SetupInterruptControllers()
{
  /* Set up the interrupt controller chip: */

  outb(0x11, 0x20);		/* ctrlr1 init - edge triggered */
  outb(0x20, 0x21);		/* interrupts from 0x20 to 0x27 */
  outb(0x04, 0x21);		/* cascade on IRQ2 */
  outb(0x01, 0x21);		/* 8086 mode */
  outb(0xff, 0x21);		/* disable interrupts on pic1 */

  outb(0x11, 0xa0);		/* ctrlr2 init - edge triggered */
  outb(0x28, 0xa1);		/* interrupts from 0x28 to 0x2f */
  outb(0x02, 0xa1);		/* cascade on IRQ2 */
  outb(0x01, 0xa1);		/* 8086 mode */
  outb(0xff, 0xa1);		/* disable interrupts on pic1 */

  outb(0x20, 0x20);		/* reset pic1 */
  outb(0x20, 0xa0);		/* reset pic2 */
}


#if 0
extern void CheckConsistency(const char *);
extern bool CheckUserContexts(const char *);
#endif


void
idt_UnboundVector(savearea_t *saveArea)
{
#if 0
  fatal(
		"** Unbound vector 0x%x  EIP =  0x%x  FVA=0x%08x  Code=0x%x\n"
		"   Trap Depth = %d pic1 = 0x%02x pic2 = 0x%02x\n",
		saveArea->ExceptionNo, saveArea->EIP,
		saveArea->ExceptionAddr, saveArea->Error,
		TrapDepth, pic1_cache, pic2_cache);
#else
  fatal(
		"** Unbound vector 0x%x  EIP =  0x%x  FVA=0x%08x  Code=0x%x\n",
		saveArea->ExceptNo, saveArea->EIP,
		saveArea->ExceptAddr, saveArea->Error);
#endif
}



void
idt_YieldVector(savearea_t * sa/* sa */)
{
  /* Simply set the global that indicates we must reschedule.  This
   * could be inlined, but since it only happens in kernel-mode
   * interrupts (and then infrequently) it's better not to stick more
   * tests on the common interrupt path.
   */
  act_ForceResched(0); /* parameter is unused in act_ForceResched */
}


/* register an interrupt handler */

void
idt_WireVector(uint32_t vector, void (*pf)(savearea_t* sa))
{
  irq_DISABLE();
  IntVecEntry[vector] = pf;
  irq_ENABLE();
}



void
irq_SetHandler(uint32_t irq, void (*pf)(savearea_t *sa))
{
  printf("Setting irq %d\n", irq);
  idt_WireVector(iv_IRQ0 + irq, pf);
}



InterruptHandler
irq_GetHandler(uint32_t irq)
{
  return idt_GetVector(iv_IRQ0 + irq);
}



void
irq_UnsetHandler(uint32_t irq)
{
  assert (irq >= 0 && irq <= 15);

  printf("Unsetting irq %d\n", irq);
  idt_WireVector(iv_IRQ0 + irq, irq_UnboundInterrupt);
}

