package capros;

/** Kernel interface to object ranges.
 *
 * The Range interface provides the primitive means for the allocation
 * and deallocation of page and node keys.
 */
interface Range extends key raises(RangeErr, NotMounted, IoErr) {
  exception RangeErr;
  exception NotMounted;
  exception IoErr;

  typedef unsigned long long off_t;
  typedef unsigned long count_t;

  /* Object types returned by identify: */
  typedef unsigned byte obType;
  const obType otPage = 0;
  const obType otNode = 1;
  const obType otForwarder = 2;
  const obType otGPT = 3;
  const obType otNUM_TYPES = 4;
  const obType otNone = 255;

  /** Query a range.
   *
   * Reports the length of a given range.
   */
  unsigned long long /* should be off_t, but CapIDL has a bug */ query();

  /** Identify an object.
   *
   * Determines whether an object originated from a give range, and if
   * so, at what offset relative to the start of the range.
     Raises RangeErr if key is not a Page, Node, Forwarder, or GPT key,
     or it is opaque, or the object is not in this range.
   */
  void identify(capros.key key, out obType type, 
    out unsigned long long /* should be off_t, but CapIDL has a bug */ offset);

  /** Rescind an object.
   *
   * Rescinds the passed key if and only if it is a read-write key to
   * an object that was allocated from this range.
   * Also resets the state of the object to a null state
   * (zero data, void capabilities), and immediately cleans it and steals it.
   */
  void rescind(capros.key key);

  /** Create key to page.
   *
   * Creates a page key to the designated page if and only if the
   * offset falls within the legal bounds of this range. If the range
   * is dismounted or otherwise unavailable, this operation will throw
   * the /RangeErr/ exception.
   */
  capros.key getPageKey(
    unsigned long long /* should be off_t, but CapIDL has a bug */ offset);

  /** Create key to page (blocking).
   *
   * Creates a page key to the designated page if and only if the
   * offset falls within the legal bounds of this range. If the range
   * is dismounted or otherwise unavailable, this operation will block
   * until the range becomes available.
   */
  capros.key waitPageKey(
    unsigned long long /* should be off_t, but CapIDL has a bug */ offset);

  /** Create a capability to an object.
   *
   * type specifies the type of capability to create.
   * offset specifies the offset within this range of the OID of the object.
   * Create a capability to the specified object.
   * If the range is dismounted or otherwise unavailable,
   * this operation will throw the /RangeErr/ exception.
   */
  capros.key getCap(obType type,
    unsigned long long /* should be off_t, but CapIDL has a bug */ offset);

  /** Create a capability to an object (blocking).
   *
   * type specifies the type of capability to create.
   * offset specifies the offset within this range of the OID of the object.
   * Create a capability to the specified object.
   * If the range is dismounted or otherwise unavailable,
   * this operation will throw the /RangeErr/ exception.
   */
  capros.key waitCap(obType type,
    unsigned long long /* should be off_t, but CapIDL has a bug */ offset);

  /** Compare two ranges for overlap or relative position.
   *
   * On return:
   *
   * if the ranges do not overlap:
   *   /how/ is 0.
   * if start(/krCmpRange/) &gt; start(this):
   *   /how/ is 1 and /offset/ = /krCmpRange/'s start relative to 
   *   the start of /this/
   * if start(/krCmpRange/) == start(this):
   *   /how/ is 2 and /offset/ = 0
   * if start(/krCmpRange/) &lt; start(this):
   *   /how/ is 3 and /offset/ = /this/'s start relative to
   *   the start of /krCmpRange/
   */

  void compare(capros.Range krCmpRange, out unsigned long how,
    out unsigned long long /* should be off_t, but CapIDL has a bug */ offset);

  /** Report next populated subrange.
   *
   * Returns the offset and length of the next subrange for which
   * backing objects actually exist, starting the search at offset
   * /startOffset/ of the passed range key.
   */
  void nextSubrange(
    unsigned long long /* should be off_t, but CapIDL has a bug */ startOffset, 
    out unsigned long long /* should be off_t */ offset,
    out unsigned long len);

  /** Create a range key for a subrange of this range.
   *
   * Returns a range key for a subrange of the current range,
   * begininng at /offset/ and extending for /len/ frames.
   */
  capros.Range makeSubrange(
    unsigned long long /* should be off_t, but CapIDL has a bug */ offset,
    unsigned long len);

  /** Get counts.
   *
   * offset specifies the offset within this range of the OID of an object.
   * Returns the allocation count and call count of the object.
   * If the object does not have a call count, the allocation count
   * is returned in both parameters.
   */
  void getFrameCounts(
    unsigned long long /* should be off_t, but CapIDL has a bug */ offset,
    out count_t allocationCount, out count_t callCount);

  /** Retype a frame.
   *
   * offset specifies a frame (the offset within frame must be zero).
   * oldType is the current base type of the frame.
   * newType is the base type that the frame will be changed to.
   * allocationCount and callCount specify the allocation count and
   * call count (for objects that use it) for the new object(s) in the frame.
   */
  void retypeFrame(
    unsigned long long /* should be off_t, but CapIDL has a bug */ offset,
    obType oldType, obType newType,
    count_t allocationCout, count_t callCount);
};
