package capros;

/** Interface to allow processes to sleep voluntarily.
 */
interface Sleep extends key {
  typedef unsigned <64> nanoseconds_t;
  /* The following does not work due to a bug in capidl:
  const unsigned <64> infiniteTime = 18446744073709000000; // about UINT64_MAX
  */
  /* (Note: 2**64 nanoseconds is about 584 years.) */

  /* Returns the time in nanoseconds since some time in the past. 
     FIXME: Is this monotonic over checkpoint/restart? */
  nostub /* Stub generated by hand, because capidl has a bug. */
  nanoseconds_t getTimeMonotonic();

  /** Sleep until the specified number of milliseconds has passed */
  void sleep(unsigned long long ms);

  /** Sleep until the specified number of nanoseconds has passed */
  // Due to a bug in capidl, it does not work to use nanoseconds_t here.
  void sleepForNanoseconds(unsigned long long /* nanoseconds_t */ ns);

  /** Sleep until getTimeMonotonic() >= ns. */
  // Due to a bug in capidl, it does not work to use nanoseconds_t here.
  void sleepTill(unsigned long long /* nanoseconds_t */ ns);


  const unsigned long DelayMaxMicroseconds = 5000000;
	// Delaying more than 5 seconds is a waste of the processor.

  /** Delay in a spin loop for the specified number of microseconds,
      which must be less than DelayMaxMicroseconds.

      This method is not an invocation and it can be executed with
      interrupts disabled. */
  client void delayMicroseconds(unsigned long microseconds,
                         unsigned long calibrationConstant);

  /** Get the calibration constant to be passed to delayMicroseconds. */
  unsigned long getDelayCalibration();
};
