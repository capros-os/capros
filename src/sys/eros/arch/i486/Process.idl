package capros.arch.i386;

/* Interface to IA32 process keys.
 */
interface Process extends capros.Process raises (capros.key.RequestError) {

  struct Registers {
    // CommonRegisters32 fields:
    unsigned long len;
    unsigned long arch;
    unsigned long procFlags;
    unsigned long faultCode;
    unsigned long faultInfo;
    unsigned long pc;	// program counter
    unsigned long sp;	// stack pointer

    // Architecture-specific fields:
    unsigned long EDI;
    unsigned long ESI;
    unsigned long EBP;
    unsigned long EBX;
    unsigned long EDX;
    unsigned long ECX;
    unsigned long EAX;
    unsigned long EFLAGS;
    unsigned <16> CS;
    unsigned <16> SS;
    unsigned <16> ES;
    unsigned <16> DS;
    unsigned <16> FS;
    unsigned <16> GS;
/*
  uint32_t  fp_ctrlReg;
  uint32_t  fp_statusReg;
  uint32_t  fp_tagWord;
  uint32_t  fip;		// floating instruction pointer
  uint32_t  fcs;		// floating code seg
  uint32_t  fdp;		// floating data pointer
  uint32_t  fds;		// floating data segment
  uint16_t  st[8][5];		// register values
*/
  };

  // Segment register values:
  // In (n*8 + 3), n is the index in the GDT, 
  // and 3 is the Requested Privilege Level.
  const unsigned <16> CodeSeg = (4*8 + 3);
  const unsigned <16> DataSeg = (5*8 + 3);
  const unsigned <16> PseudoSeg = (6*8 + 3);

  /*unsigned long*/ enum FC {

    /* IA-32 specific trap codes: */

    /// @brief General Protection fault.
    GeneralProtection = 128,

    /// @brief Stack Segment fault.
    StackSeg = 129,

    /// @brief Segment Not Present fault.
    SegNotPresent = 130,

    /// @brief SIMD floating point error.
    SIMDfp = 131,

    /// @brief Overflow trap.
    Overflow = 132,

    /// @brief Bounds Violation.
    Bounds = 133,

    /// @brief Process has invalid segment register.
    InvalidSegReg = 134,

    /// @brief Invalid TSS.
    InvalidTSS = 135
  };

  Registers getRegisters();
  void setRegisters(Registers regs);

  void setIoSpace(capros.key devprivskey);
};
