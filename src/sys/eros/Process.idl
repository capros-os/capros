package capros;

/* Interface to process keys.
 */
interface Process extends key raises (key.RequestError) {
  exception Malformed;

  typedef unsigned byte KeyRegSlot;
  typedef unsigned <16> StartKeyPayload;

  struct CommonRegisters32 {
    unsigned long len;		// ignored when writing
    unsigned long arch;		// ignored when writing
    unsigned long procFlags;
    unsigned long faultCode;
    unsigned long faultInfo;
    unsigned long pc;	// program counter
    unsigned long sp;	// stack pointer
  };

  // Values for arch:
  const unsigned long ARCH_I386       = 0;
  const unsigned long ARCH_ARMProcess = 2;

  // Bits in procFlags:
  const unsigned long PF_FaultToProcessKeeper = 1;
  const unsigned long PF_ExpectingMessage = 2;

  /// @brief Fault (exception) codes.
  ///
  /// Some of these fault codes are generated by the kernel, and some are
  /// generated by the processor but are architecture-independent.
  /// In addition, some architectures extend this code
  /// space with additional, architecture-specific extensions. FC code
  /// points beginning at 128 are reserved for architecture-specific
  /// fault codes.
  unsigned long enum FC {
    /// @brief Process currently does not have any fault.
    NoFault = 0,

    /// @brief System call parameters were malformed, or system call
    /// number unknown.
    MalformedSyscall = 1,

    /// @brief Issued address was undefined.
    InvalidAddr = 4,

    /// @brief Cannot write to specified address.
    AccessViolation = 6,

    /// @brief GPT traversal limit exceeded in address space reference.
    TraverseLimit = 12, 

    /// @brief Address space GPT arrangement is malformed, or GPT
    /// contains an inappropriate capability type.
    MalformedSpace = 13,

    /// @brief Process has invalid/maltyped schedule capability.
    NoSchedule = 33,

    /// @brief Process encountered a breakpoint instruction (PC=@&bpt).
    ///
    /// This fault code is used on architectures where the breakpoint
    /// instruction does not advance the program counter, or when the
    /// kernel can automatically roll the program counter back to
    /// point to the breakpoint instruction.
    BreakPoint = 34,

    /// @brief Process encountered a breakpoint instruction (PC=@&bpt+1).
    ///
    /// This fault code is used on architectures where it is
    /// impossible to automatically recover the correct address of the
    /// breakpoint instruction. On architectures where the address of
    /// the breakpoint instruction can be reliably re-established in
    /// software, the kernel will back up the instruction pointer and
    /// report the BreakPoint exception instead.
    BrokePoint = 35,

    /// @brief Process issued an illegal or unknown instruction.
    BadOpcode = 36,

    /// @brief Process marked as ``alien'' performed an invocation
    /// instruction.
    Alien = 37,

    /// @brief Process performed an integer divide by zero
    DivZero = 38,

    /// @brief Process performed a checked misaligned memory reference.
    Alignment = 39,
    
    /// @brief Floating point error.
    ///
    /// Floating point exception or fault. More detailed information about
    /// the error should be obtained by executing the architecture
    /// specific GetRegsFP() operation and examining the appropriate
    /// floating point status register.
    FPFault = 41,

    /// @brief Backing store has unrecoverably lost the state of this object.
    ObjectContentLost = 49,

    /// @brief Process is malformed.
    MalformedProcess = 50
  };

  capros.key getSchedule();
  capros.key swapSchedule(capros.key newKey);

  capros.key getAddrSpace();
  capros.key swapAddrSpace(capros.key newKey);
  /* For architectures where the PC is 32 bits: */
  capros.key swapAddrSpaceAndPC32(capros.key newKey, unsigned long newPC);
  capros.key swapAddrSpaceAndPC32Proto(capros.key newKey, unsigned long newPC,
               unsigned long w2_in, out unsigned long w1_out);

  capros.key getKeeper();
  capros.key swapKeeper(capros.key newKey);

  capros.key getSymSpace();
  capros.key swapSymSpace(capros.key newKey);

  capros.key getKeyReg(KeyRegSlot kr);
  capros.key swapKeyReg(KeyRegSlot kr, capros.key newKey);

  capros.key makeStartKey(StartKeyPayload pl);
  capros.key makeResumeKey();

  /* For architectures where the PC and SP are 32 bits: */
  CommonRegisters32 getRegisters32();
  void setRegisters32(CommonRegisters32 regs);
};
