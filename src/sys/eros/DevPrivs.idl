package capros;

/** Kernel support for device drivers.
 *
 * The DevPrivs interface exports control over interrupts and device
 * memory mapping for use by application-level device drivers.
 *
 * Any of these operations may fail with the AllocFail exception if
 * the specified IRQ is not presently allocated.
 */
interface DevPrivs extends key raises(AllocFail) {
  exception AllocFail;

  typedef unsigned long long addr_t;

  /* The largest block that can be allocated using allocateDMAPages
  is 2**logMaxDMABlockSize. */
  const unsigned short logMaxDMABlockSize = 7;

  /** Allocate an IRQ.
   *
   * Indicates to the kernel that the specified IRQ now has a driver
   * that is listening for it.
   * priority is architecture-specific
   */
  void allocIRQ(unsigned long irq, long priority);

  /** Release an IRQ.
   *
   * Indicates to the kernel that the specified IRQ no longer has a driver
   * that is listening for it.
     The IRQ is also disabled.

     If there is a process waiting for an interrupt on the specified IRQ,
     it is restarted. Normally it will then receive AllocFail, but
     there is a race condition if another process tries to allocate
     the same irq.
   */
  void releaseIRQ(unsigned long irq);

  /** Enable an IRQ.
   *
   * Indicates to the kernel that the specified IRQ should be enabled.
   */
  void enableIRQ(unsigned long irq);

  /** Disable an IRQ.
   *
   * Indicates to the kernel that the specified IRQ should be disabled.
   */
  void disableIRQ(unsigned long irq);

  /** Wait for interrupt.
   *
   * Wait for a designated interrupt to arrive.
     While waiting, the IRQ will be enabled.
     Raises AllocFail if the specified irq is not allocated.
     On successful return, the IRQ has been disabled.
   */
  void waitIRQ(unsigned long irq);

  /** Publish device memory.
   *
   * Inform the kernel that a hardware device publishes (presents to
   * the bus) a physical memory region that was previously unknown to
   * the kernel.
   */
  void publishMem(unsigned long start, unsigned long end, boolean readOnly);

  /** Modify the system's device configuration register (ARM EP93xx only).

     Set or clear the bit(s) in the mask.
     The bit(s) in the mask must also be present in this key's
     u.nk.value[0] field, otherwise key.NoAccess is raised.
   */
  void deviceConfig(boolean set, unsigned long mask);

  /** Allocate pages for DMA.

  If nPages %gt; 2**logMaxDMABlockSize, RequestError is raised.

  Allocate a block of nPages pages that have contiguous physical addresses.
  All the physical addresses p are such that (p &amp; addrMask) == p.
  They physical address of the first page is returned in physAddr.
  A page key to the first page is returned; use ... to get subsequent pages. */
  capros.Page allocateDMAPages(unsigned short nPages,
                               addr_t addrMask, out addr_t physAddr);

  /** Deallocate pages for DMA.

  Deallocate the block of pages represented by pg, which must be a
  capability returned from allocateDMAPages.
  Caller must ensure there is no I/O in progress to the pages. */
  void deallocateDMAPages(capros.Page pg);
};

interface DevPrivs32 extends DevPrivs raises(DevPrivs.AllocFail) {
  /** Allocate an IOReqQ32.
   */
  capros.IOReqQ32 allocateIORQ();
};
