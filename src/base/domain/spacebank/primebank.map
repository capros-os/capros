/* -*-C-*- */

/*
 * Copyright (C) 1998, 1999, Jonathan Adams.
 * Copyright (C) 2001, The EROS Group.
 * Copyright (C) 2006, Strawberry Development Group.
 *
 * This file is part of the EROS Operating System runtime library.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, 59 Temple Place - Suite 330 Boston, MA 02111-1307, USA.
 */

#ifdef __PRIMEBANK_MAP__
#error "primebank.map multiply included"
#endif
#define __PRIMEBANK_MAP__

/* This is a temporary expedient to avoid rebuilding multiple test
 * cases until I am sure this is all correct. */
#ifndef __DESTROY_MAP__
#include <destroy.map>
#endif

/*********************************************
 * PRIME SPACE BANK
 *********************************************/

#include <eros/machine/target-asm.h>
#include <eros/KeyConst.h>
#include <domain/Runtime.h>

/* Format key value indicating presence of no initial slots plus
   keeper key in keeper slot, invocation convention to NOT send node key: */

/* BLSS=0x3u BG=0x1fu KPR=0x1eu SEND=0 (no) initial=0
 *  0011 11111 11110 00000 00000
 *  0011 1111 1111 1000 0000 0000
 */
#define BARE_REDSPACE_FORMAT 0x3FF800

spacebank = new process with constituents;

spacebank.seg = program segment LIBDIR "spacebank";

/* add a page for the stack: */
spacebank.seg = spacebank.seg with page at 0xff000;

/* Need to do this in several chunks so that we don't run afoul of
   segment insertion rules: */
rangemap.seg = empty segtree with 1024 pages;
spacebank.seg = spacebank.seg with subseg rangemap.seg at 0x01000000;
rangemap.seg = empty segtree with 1024 pages;
spacebank.seg = spacebank.seg with subseg rangemap.seg at 0x01400000;
rangemap.seg = empty segtree with 1024 pages;
spacebank.seg = spacebank.seg with subseg rangemap.seg at 0x01800000;
rangemap.seg = empty segtree with 1024 pages;
spacebank.seg = spacebank.seg with subseg rangemap.seg at 0x01c00000;

hide rangemap.seg;

primeseg = new node with lss EROS_ADDRESS_LSS;
primeseg[0] = spacebank.seg;
spacebank.seg = primeseg;
hide primeseg;

spacebank pc = symbol LIBDIR "spacebank" _start;
spacebank space = spacebank.seg;
spacebank schedule = sched(8);   /* normal */
spacebank symtab = number("spacebank");

hide spacebank.seg;

/* Official space bank brand is a distinguished start key to the space bank: */

spacebank brand = start spacebank 65535;

CONSTIT(spacebank, KC_PRIMERANGE, 0) = prime range;
CONSTIT(spacebank, KC_VOLSIZE, 1) = volsize;
CONSTIT(spacebank, KC_OSTREAM, 2) = misc Console;
CONSTIT(spacebank, KC_DOMTOOL, 3) = misc ProcessTool;

/* Set up a distinguished node that will hold the "runtime bits" for
 * all of the primordial processes. Various slots of this will be set
 * up in later places, so we need to be careful to reuse this node
 * rather than clone it, and the boot constructor logic has to clone
 * this node by hand.
 *
 * The primordial runtime bits do not include a creator or a
 * constructor verifier, because none
 * of the primordial domains (spacebank, pcc, metacontstructor) ever
 * exits, and none ever test constructors. In spite of this, pcc.map
 * back-patches the creator slot to PCC so that process creators can
 * simply reuse primordial_runtime_bits as their runtime node. We
 * include the destroy space for the same reason.
 *
 * Finally note that we use lss 0 explicitly to allow/encourage use of
 * the extended node copy/swap operations. This will allow us to
 * expand the tree of runtime bits later in a compatible way. */

primordial_runtime_bits = new ro node with lss 0;
primordial_runtime_bits[RKT_CREATOR]       = misc Void; /* never exit */
primordial_runtime_bits[RKT_DESTROY_SPACE] = destroy_space;
   /* RKT_SB_VERIFIER reset below in primebank.map */
primordial_runtime_bits[RKT_SB_VERIFIER]   = misc Void;
  /* Note that RKT_CNS_VERIFIER is not used by any of the primordial
   * domains, but is reset in metacon.map so that the constructor can
   * clone this node, override the creator, and pass the result to new
   * yields as their runtime environment. */
primordial_runtime_bits[RKT_CNS_VERIFIER]  = misc Void;
  /* RKT_AUDIT_LOG temporarily set here to KR_OSTREAM, but will
   * eventually be overridden in syslog.map */
primordial_runtime_bits[RKT_AUDIT_LOG]     = misc Console;

spacebank key reg  KR_SELF = spacebank; /* domain key to spacebank */
spacebank key reg  KR_RTBITS = primordial_runtime_bits;

hide volsize; /* for my eyes only */

run spacebank;

/* set up the precreated bank keys
 * NOTE:  The space bank initialization code will overwrite these nodes
 * with all of the correct values.  However, it is necessary that these
 * be a valid segment keys with a valid keeper key in slot zero which
 * is a start key to the spacebank, so that calls before
 * initialization is complete will not fail.
 *
 * The names and key registers must match /premade_keys/ in Bank.c
 */
primebank = new node;
primebank[WrapperKeeper] = start spacebank 0x03; /* no destroy, no chg limits */
primebank[WrapperFormat] = number (WRAPPER_KEEPER);

CONSTIT(spacebank, KC_PRIMEBANK, 4) = primebank; /* a NODE key */
primebank = primebank as wrapper key;

bank_verifier = new node;
bank_verifier[WrapperKeeper] = start spacebank 0x03; /* no destroy, no chg limits */
bank_verifier[WrapperFormat] = number (WRAPPER_KEEPER);

CONSTIT(spacebank, KC_VERIFIER, 5) = bank_verifier as node key;

bank_verifier = bank_verifier as wrapper key;

primordial_runtime_bits[RKT_SB_VERIFIER] = bank_verifier;

hide spacebank;
