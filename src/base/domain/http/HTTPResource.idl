package capros;

interface HTTPResource extends key {
  unsigned short enum Method {
    OPTIONS = 0,
    GET = 1,
    HEAD = 2,
    POST = 3,
    PUT = 4,
    DELETE = 5,
    TRACE = 6,
    CONNECT = 7
  };

  unsigned short enum RHType {
    HTTPRequestHandler = 0,
    File = 1
  };

  // HTTPVersion is (major number) * 65536 + (minor number).
  typedef unsigned long HTTPVersion;

  /*
  If rhtype is HTTPRequestHandler, rh is an HTTPRequestHandler
    and sendLimit is the maximum number of bytes that the
    HTTPRequestHandler can receive in the first headers() call.
  If rhtype is File, rh is a File and sendLimit is unused
  */
  void request(HTTPVersion httpVersion,
               Method m,
               unsigned long lengthOfPath,
               unsigned long lengthOfPathAndQuery,
	/* The following is really an input string: */
               out unsigned byte pathAndQuery,
	// Here are the real outputs:
               out RHType rhtype,
               out key rh,
               out unsigned long sendLimit);
};

interface HTTPRequestHandler extends key {
  /* HTTPRequestHandler methods can only be called in the order in which
  they appear below, otherwise key.RequestError is raised. */

  /** headers - transfer the header data

  The header data consists of the following in order:
    For each header:
      one byte containing the length of the field name;
      two bytes containing the length of the field value (without any
        leading or trailing white space), in native endianness;
      the field name;
      the field value (without any leading or trailing white space)
    One byte containing zero (indicating the end of the list).

  All headers present in the request are transferred (including
  any Content-Length header), except:
    Transfer-Encoding

  sendLimit is the maximum number of bytes that this object can receive
    in the next headers() call or, if this is the last headers() call,
    the first body() call.
  */
  void headers(unsigned long lengthOfHeaderData,
	/* The following is really an input string: */
               out unsigned byte headerData,
	// Here are the real outputs:
               out unsigned long sendLimit);

  /*
  If the request contained an Expect header with the "100-continue" expectation,
  the server will call the getContinueStatus method.
  If the returned statusCode is 100 (continue), the server sends that
  status code to the client, and continues reading the body.
  Otherwise, the status code is sent to the client, ending the request
  and response. 

  The "100-continue" expectation is consumed by the server and not passed
  to HTTPRequestHandler.headers().
  */
  void getContinueStatus(out unsigned short statusCode);

  /** body - transfer the entity-body

  If lengthOfBodyData is zero, that indicates the end of the body,
  and sendLimit is used as the limit for the transfer of trailers, if any.
  */
  void body(unsigned long lengthOfBodyData,
	/* The following is really an input string: */
            out unsigned byte bodyData,
	// Here are the real outputs:
            out unsigned long sendLimit);

  /** trailer - transfer the trailer headers

  If the headers contained a Trailer header, the server calls trailer()
  to deliver the trailer headers.
  The trailer header data has the same format as the request header data.

  If lengthOfTrailerData is zero, that indicates the end of the trailer,
  and sendLimit is ignored.
  */
  void trailer(unsigned long lengthOfTrailerData,
        /* The following is really an input string: */
            out unsigned byte trailerData,
        // Here are the real outputs:
            out unsigned long sendLimit);

  /* getResponseStatus

  Get the status code of the resource's response to the request.
  The server will supply an appropriate reason phrase to the client. 
  The server will specify an HTTP version of 1.1 for the response.
  */
  void getResponseStatus(
            out unsigned short statusCode);

  /** getResponseHeaderData - get the response headers

  dataLimit is the maximum number of bytes that may be returned.
  The response header data has the same format as the request header data.
  The following headers MUST NOT be present:
    Transfer-Encoding
  (Content-Length: should it be a header, or specified as a number somewhere?)
  */
  void getResponseHeaderData(
          unsigned long dataLimit,
          out unsigned long lengthOfHeaderData,
	/* The following is really an output string: */
          out unsigned byte headerData);

  /** getResponseBody - get the entity-body of the response

  dataLimit is the maximum number of bytes that may be returned.

  If lengthOfBodyData is zero, that indicates the end of the body,
  and dataLimit is the limit of trailer data if any.
  */
  void getResponseBody(
          unsigned long dataLimit,
          out unsigned long lengthOfBodyData,
	/* The following is really an output string: */
          out unsigned byte bodyData);

  /** getResponseTrailer - transfer the trailer headers

  If the response headers contained a Trailer header, the server calls trailer()
  to get the trailer headers.
  The trailer header data has the same format as the request header data.

  If lengthOfTrailerData is zero, that indicates the end of the trailer,
  and sendLimit is ignored.
  After this call, the only valid call is key.destroy.
  */
  void getResponseTrailer(unsigned long lengthOfTrailerData,
        /* The following is really an input string: */
            out unsigned byte trailerData,
        // Here are the real outputs:
            out unsigned long sendLimit);

  /* HTTPRequestHandler obeys key.destroy(). */
};
