<html>
<head>
<title>EROS Window System</title>
</head>
<BODY BGCOLOR="#ffeedd" text="#000000" link="#0000ee" vlink="#551a8b" alink="#ff0000"><table><tr valign=top><td width="10%">&nbsp;</td><td><div class=nocss><br class=nocss>&nbsp;<br class=nocss>&nbsp;</div>
<center>
  <H1>EROS Window System</H1>
</center>
<p> The purpose of this document is to capture design issues,
solutions, discussions, and any other pertinent data regarding the
design and implementation of a windowing system for EROS.

<p> The EROS Window System supports overlapping, hierarchical
graphical windows (much like X11 or any other popular windowing
system).  Following the basic EROS domain design pattern, the window
system is a "user-space" domain that simply services client requests.
It's vital that the window system never block while servicing requests
and it helps greatly if the window system can be a single thread.
There are a few critical design issues that arose as soon as a
preliminary window system was prototyped: 
<ul> 
  <li>What capabilities should the window system generate and manage?</li> 
  <li>How should the system support a hierarchical window structure?</li> 
  <li>Proper behaviour of window system clients</li> 
  <li>Graphics layer API for clients and window system</li>
</ul>

<h2>What Capabilities to Provide to Clients</h2>
<p> Originally it was logical to insist that an EROS capability would
exist for any and all graphical windows.  Although such a design is
certainly possible, it introduces some unwanted effects.
  
<p> First, a window system client domain must be able to monitor (or
listen for) events of interest, such as keyboard or mouse input,
signals from the window system that certain subregions have been
exposed (a.k.a. expose events), etc.  An average client application
could easily have tens of individual windows and this means that such
a client must have the means for listening for events on tens
of keys.  Since there exist window system clients that must render
contents while listening for events, this requires that a client have
a separate thread for each window dedicated to listening for
events. While the requirement for a client to be multi-threaded if it
needs to independently render contents may not be avoidable, certainly
limiting the number of required threads is attractive.  A mechanism
for dispatching events to a client in a more general manner would help
limit the number of required threads for a client.

<p> Second, management of keys quickly becomes a logistical nightmare
for both the window system and its clients if each window has its own
key.  Recall that keys must be stored in nodes and there isn't a very
straightforward way of building and maintaining an unbounded list of
keys (stored in nodes).  It's much easier for the window system to
manage pointers and it's much easier for clients to manage integer
window ids that can be mapped to such pointers.

<p> Third, it became apparent that an owner (window system client) of
a graphical window needs to be able to grant a "subwindow" for use by
another client, either in a "trusted" or "nontrusted" mode.  (This
notion of "trust" means whether the content in that graphical window
is generated by a client that is trusted to be well-behaved or a
domain that cannot be trusted to be well-behaved.)  A design that
generates unique capabilities per graphical window doesn't lend itself
well to this goal.

<p> All of these issues led to the notion of a client Session.

<h2>Sessions</h2>
<p> We introduced the Session object as the means by which any client
domain interacts with the window system.  Instead of unique keys for
each graphical window, the window system generates one key for an
entire client Session (which can be thought of as a duration during
which a client will create and manipulate various graphical
windows). The client domain uses such a key to create windows, render
contents in windows, close windows and, as previously discussed,
create "sub session" keys that can then be distributed to other
clients.  Thus the Session key is the one with the finest resolution
from the client's perspective.  All window operations are performed
via a Session key and when a client ends a Session, all graphics
windows created via that Session are destroyed.  

<p> Although the total number of Sessions is potentially unbounded,
the window system need not maintain a hierarchy of Session objects.
As windows are created within a Session, the window system can simply
keep a list of pointers that reference the individual windows and the
Session object merely needs to track the root of that list.  This
approach alleviates the need for a complex hierarchy of nodes in which
to store/manage client keys.

<p> Furthermore, event notification is handled on a per-Session basis.
The client only needs one thread per Session to listen for events of
interest.  The window system dispatches events via a Session key
invocation and includes an individual window identification that the
client can use as a hint for processing that event.  Note that this
design necessarily requires review with regard to propagation of
events, because a client is free to process a retrieved event in any
manner it wishes, including making such an event visible to any or all
of its windows.

<p> Sessions are classified as either <em>Trusted</em> or
<em>Untrusted</em>. Initially, a window system client is issued a key
by which either session may be created.  A client must create one of
these types of Sessions before creating and/or manipulating any
windows.  <em>We still haven't worked out how the creator key for
Trusted Sessions is managed.</em>

<h3>Trusted Sessions</h3>
<p> A <em>trusted</em> Session is one in which all windows that are
created via its key are known to have contents rendered from a
well-behaved client domain (ie. a domain that is a member of the
trusted computing base).  All windows created via a trusted Session
key are, in turn, trusted and should have some visual distinction or
cue so users can easily identify them.  A classic example of a trusted
window is a dialog that prompts the user for a secret password.  A
user needs to know that such a window is trusted before entering a
password.

<h3>Untrusted Sessions</h3>
<p> Conversely, an <em>untrusted</em> Session is one in which all
windows created via its key have contents that a user cannot determine
were rendered by well-behaved client(s).  A classic example is an
Internet browser window.  There are several web pages in the Internet
that attempt to execute malicious code.  Note that the goal is not to
prevent untrusted clients from rendering window contents.  Rather, the
goal is to distinguish such clients from known, trusted ones.  The use
of a distinct capability for each Session will guarantee that
untrusted windows are confined appropriately.

<h2>Maintaining Window Hierarchy</h2>
<p> It's common practice for window systems to allow clients to create
sub-windows or child windows.  The best known examples are buttons, menus and
other widgets that typically decorate the borders or frames of
windows.  Child windows can be expressed or defined
in terms of their parents and all child windows are clipped to their
parent.  Also, whenever a parent window is destroyed, all of its
children (recursively) are destroyed.  However, supporting this notion
requires a design decision regarding where the window hierarchy is
maintained:  client or server.  If the client is forced to maintain
this hierarchy, then the server's tasks are simplified since it never
has to recursively process a hierarchy of windows.  However, this
obviously makes the client's job more complex, since it must then
manage and dispatch events to all of its child windows appropriately.

<p> In EROS, the window system will maintain the window hierarchy.
The main advantage is that the window system can perform all needed
clipping associated with mapping and movement of windows.  In
addition, the window system can be responsible for the look and feel
of windows in general and the client can concentrate on window
contents. The window system and its client domains share the address
spaces that contain the pixel data for the contents of the windows.
However, the clients are responsible for ensuring that window
contents are current.  The window system will generate appropriate
events for the clients.

<p> *** Window system only brings to front or moves to back top-level
windows!  Client is responsible for requesting reordering of child
windows.  But, window system will generate and dispatch all necessary
expose events for all windows (including children) when reordering
top-level windows!

<p> *** Focus should be configurable.  Focus need not change order of
top-level windows, but that should be configurable as well!
Currently, a window that is given focus is automatically moved in
front of all its siblings.

<p> *** Decorations are handled entirely by window system. For a given
client window, the window system will create and manage one decoration
window with possibly (depending on actual implementation) one or more
child window for widgets (like the kill button).

<p> The above bullets may now be obsolete.  Current design discussions
have introduced the concept of child <em>sessions</em> in order to
implement child windows.  More documentation on this concept will be
provided later.

<h2>The Session Object</h2>
<p> The window system must maintain a unique Session object
corresponding to each unique Session capability that it generates.
When a new Session is created, the window system allocates memory for
the new object, then fabricates a wrapper node into which the address
for the new object is embedded.  The wrapper key to this new node is
the actual key that a client receives.  By embedding the reference to
the Session in the wrapper node, no client can invoke any other
Session other than one for which it has a capability. Furthermore, the
window system need not maintain any specific list of active sessions
because it can easily determine the appropriate Session via the
capability that is invoked by the client.  No additional mapping needs
to be maintained.

<p>The Session object contains the following data:
<ul>
  <li>Whether particular instantiation is trusted</li>
  <li>Reference to the root of a tree containing the mappings from
  window ids to actual addresses of Window objects</li>
  <li>Event queue</li>
</ul>

<p> Unlike for Session objects, the window system <em>does</em> need to
maintain a list of all Windows within a Session.  Recall that a
client's invocation for a service on a particular window must
reference a window id.  That window id must be mapped to the actual
underlying Window object within the Session identified by the invoked
key.  As each Window object can be referenced simply by its address,
the window system maintains a mapping (rb tree) from window ids to
addresses.  Thus, its fairly simple for the window system to identify
the window of interest on any invocation.  Note that this mapping is
independent of the overall window hierarchy that the window system maintains.

<h2>The Window Object</h2>
<p><em>Under construction...</em>

<h2>The Root Window</h2>
<p><em>Under construction...</em>

<h2>Window Management</h2>
<p> In the EROS window system, there is no separate window manager.
All window management is done internally by the window system.  This
may be changed later, but the motivation for this decision is that
window manager functions such as rendering window titles,
copying/pasting between windows, managing window focus, etc., need to
be carefully controlled in order to support properly confined
renderings by clients.  For example, key strokes meant for a trusted
password client must never be able to arbitrarily "leak" or be "heard"
by another client.  The following are the classic window management
tasks that are currently handled by the window system:
<ul> 
  <li>Creation of windows</li>
  <li>Mapping/unmapping of windows</li>
  <li>Moving windows</li> 
  <li>Managing window focus</li> 
  <li>Killing windows</li>
</ul>

<h3>Creating Windows</h3>
<p> When a window system client requests window creation (via its
Session key), the following data must be provided:
<ul>
  <li>Parent Id - If not present, window system will create this
  window as a top-level window (child of the Root window)</li>
  <li>Origin (x,y) - Specifies the location of the top left corner of
  the window within the parent window</li>
  <li>Size - specifies height and width of new window</li>
  <li>Decorations - indicates what kind of decorations the new window
  should have</li>
</ul>

<p>Barring the depletion of necessary resources, the window system will
create a new window object, generate a unique integer id for it,
insert a mapping from the id to its address in the corresponding
Session and then return the integer id to the client.  Thus, the
client only needs to maintain window ids in addition to its Session
key(s).  Any request related to a particular window are made by
invoking the Session key and providing the appropriate window id.
Note that, similar to other window systems, a newly created window is
not visible on the screen.  The client must specifically request that
the window be shown (or mapped).

<h3>Mapping/Unmapping of Windows</h3>
<p><em>Under construction...</em>

<h3>Moving Windows</h3>
<p><em>Under construction...</em>

<h3>Managing Window Focus</h3>
<p><em>Under construction...</em>

<h3>Killing Windows</h3>
<p><em>Under construction...</em>

<h3>Window Contents</h3>
<p> When a client invokes the operation to create a window, it
provides a capability to a space bank.  The window system uses the
client's space bank to create a shared memory segment to which the
window system has read access and the client has read/write access.
This shared memory area represents the pixel values of the window.
The client determines what pixel values (colors) to store and the
window system is responsible for actually relaying those pixel values
to the actual hardware framebuffer.  This design offers three major
advantages.

<p> First, the client doesn't need to face the overhead of a
capability invocation (no matter how minimal such overhead is) in
order to draw in its window.  Initial designs of our window system
required the client to issue "drawing commands" to the window system
which the window system would have to interpret.  With this new model,
the only invocation needed by the client in order to get rendered
pixels actually displayed is one "update" command to the window system.

<p> Second, the client doesn't need to be notified whenever pieces of
its windows are newly exposed.  Since the window system controls all
placement and depth of visible windows, it knows the window regions of
exposed windows and can directly (via the shared memory segments)
re-render necessary regions.  Notification of expose events sent to
clients is a potential covert channel and thus this design mitigates
that risk.

<p> Finally, this design provides the foundation for moving toward a
highly optimized graphic rendering engine for use with today's modern
graphics hardware cards.  By using shared memory segments, eventually
we can use such segments as a graphics command queue instead of a
bitmap and the window system can issue graphics commands directly to
hardware.  

<h3>Window System Memory Map</h3>
<p> This section documents the current Window System domain address
space with regard to how clients and drivers are mapped.  For mapping
memory in general, a library routine exists for user level domains
that will "prepare" a domain's default address space for mapping.
This library call (currently called "addrspace_prep_for_mapping()" and
whose source is found in ...base/lib/addrspace/) performs the
following:

<ul> 
  <li>Buys a new node from the provided space bank.</li>
  <li>Makes that new node the max LSS (which is currently 4)</li>
  <li>Inserts into slot 0 of that node the key found in ProcAddrSpace
  of the calling domain</li> 
  <li>Inserts key to that new node into ProcAddrSpace of the calling domain</li> 
  <li>Inserts 15 local window keys in slots 1-15 of the new node.  The
  local window keys reference the original address space whose segment
  key is now in slot 0.</li>
</ul>

<p> After calling "addrspace_prep_for_mapping()", a domain is free to map
page and node keys into slots 16-28 of the node whose key is in
ProcAddrSpace.

<p> The Window System has three address segments it must map:  the
video accelerated command queue (fifo queue), the framebuffer, and the
segment in which the contents of client windows are mapped.

<h4>The Command FIFO Queue</h4>
<p> The VMWare video card was the first video device supported by
EROS.  It provides a set of hardware accelerated graphics commands
that are accessed via a memory-mapped FIFO queue.  The device itself
reports the PCI start address and size of the queue.  The Window
System domain simply maps an appropriately-sized VCSK space into slot
16 of its ProcAddrSpace node.  Thus, the Window System hardcodes
address references for the command queue to start with hex address
0x80000000 (which is 2GB decimal). 

<h4>The Framebuffer</h4>
<p> The Window System uses the PCI probing domain to determine what
video device is currently available. That video device must be able to
tell the Window System the starting PCI address and the total size of
the framebuffer device.  The Window System uses this info to map an
appropriately-sized VCSK space into slot 17 of its ProcAddrSpace
node.  All references to the framebuffer space begin with hex address
0x88000000 (which is 2.125GB decimal).

<h4>Client Subspaces</h4>
<p>The Window System currently provides slots 18 to 23 in its
ProcAddrSpace node for mapping shared client segments.  The current
design provides one 8MB space for each client window. This equates to
a graphics canvas of 2048x1024 pixels, each of depth 32.  To maximize
the number of such shared areas, the top-level slots 18 to 23 hold
keys to an LSS=3 node.  Each LSS=3 node holds the keys to the shared
segments. The even-numbered slots of the LSS=3 nodes hold the keys
to the segment root and the odd-numbered slots hold local window keys
referencing the appropriate root segment slot.  

<hr> <em>Copyright 2003 by The Johns Hopkins University.  All
rights reserved.  For terms of redistribution, see the <a
href="../legal/license/GPL.html">GNU General Public License</a></em>
</td><td width="10%">&nbsp;</td></tr></table></BODY> </html>
