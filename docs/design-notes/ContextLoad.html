<html>
<head>
<title>States of The Context Structure</title>
</head>
<BODY BGCOLOR="#ffeedd" text="#000000" link="#0000ee" vlink="#551a8b" alink="#ff0000"><table><tr valign=top><td width="10%">&nbsp;</td><td><div class=nocss><br class=nocss>&nbsp;<br class=nocss>&nbsp;</div>
<center>
  <H1>States of The Context Structure</H1>
</center>
<p> Preparing a domain to run involves constructing a
<code>Context</code> structure for it.  The trend in the EROS kernel
is that more and more domain operations are being done on the
<code>Context</code> structure.  This makes sense, since the vast
majority of those operations are machine specific and the
<code>Context</code> structure is a natural place to put such things.
The remaining domain operations are things like fabricating start keys
or changing domain root slots; these are really operations on the
domain root viewed as a node, and are accomplished by first unloading
the necessary context state and then performing the operation on the
node.
<p> In shifting more and more logic in the direction of the
<code>Context</code> structure, however, we have introduced something
of a catch-22.  It becomes necessary to be able to fabricate a context
structure for a malformed domain.  This context structure need not be
runnable, but it needs to be able to capture a fault code --
specifically the <strong>FC_MalformedDomain</strong> fault code.
<p> A <em>particularly</em> ugly case is that a malformed domain may
not have a number key in the trap code slot.  Since the context
structure is a cache of domain state, it is not immediately clear in
what sense we can set a malformed fault code when the domain root
posesses no such slot.  Fortunately, this particular fault code is an
immediate consequence of the fact that the domain is malformed, and
should be reset if the domain becomes well-formed.  In this particular
case, then, it is not necessary to be able to store the fault code
value.
<p> As a side note, this approach drew to my attention a problem that
already existed but I had failed to recognize.  If a fault code is set
due to a non-restartable instruction, and the domain root somehow
becomes malformed before the non-restartable fault code is examined,
the fault code generated by the instruction can be lost.  My view on
this is that in becoming malformed the domain's execution state became
undefined.  Unlike science fiction, you don't come out of undefined
states intact.
<p> With all that as preamble, this note describes the states that a
<code>Context</code> can have in the new design.
<h2>Fabricating a Context</h2>
<p> In order to fabricate a <code>Context</code>, it is necessary and
sufficient to have a node that is the domain root of some domain.  The
domain root note is if necessary unprepared, then marked as a domain
root.  The <code>Context</code> structure is made to point to the
domain root and the domain root to the context structure.  At this
point the <code>Context</code> is said to be <strong>loaded</strong>.
The domain root need not be well-formed.  If the domain is not
well-formed, the <code>Context</code> can be loaded, but it will not
be possible to make the <code>Context</code> runnable.
<h2>Preparing a Context</h2>
<p> In general, the goal in operations on a <code>Context</code> is to
render the context <strong>runnable</strong>.  All operations on
contexts proceed by first preparing the <code>Context</code> to run.
If preparing the <code>Context</code> to run succeeds, the
<code>Context</code> will be marked <strong>runnable</strong>.  The
usual code sequence involved is:
<blockquote>
  <pre>
Context *ctxt = domainRoot->GetDomainContext();
ctxt->Prepare();
if ( ctxt->IsRunnable() )
   ...
  </pre>
</blockquote>
It may prove useful to have <code>Prepare()</code> return a boolean
indicating complete success.
<p> The vast majority of operations in the kernel can proceed
successfully only on a <code>Context</code> that is fully preparable
(i.e. one that can be rendered <strong>runnable</strong>).  The
exceptions to this are those domain key operations that manipulate the
structure of the domain itself (i.e. the ones that can alter whether a
domain is well-formed) and those that get or set register values.
<p> In support of the latter operations, <code>Context</code>
preparation can succeed partially.  In simplified form, the sequence
of states of a <code>Context</code> is:
<p>
<center>
  <table width=90%>
    <tr valign=top>
      <th align=left>State</th>
      <th align=left>Description</th>
    </tr>
    <tr valign=top>
      <td><strong>Loaded</strong></td>
      <td>The <code>Context</code> has an associated node that is a
	domain root.  The domain root node may not constitute a
	well-formed domain.</td>
    </tr>
    <tr valign=top>
      <td><strong>Well-Formed</strong></td>
      <td>The domain root node has been examined, all required domain
	annexes have been found, and all slots of the domain
	constituents have keys of appropriate type.</td>
    </tr>
    <tr valign=top>
      <td><strong>Cached</strong></td>
      <td>The domain is well-formed, and all register values have been
	cached in the context structure.</td>
    </tr>
    <tr valign=top>
      <td><strong>Runnable</strong></td>
      <td>All register values are cached, and the domain fault code is
	FC_OK, indicating an unfaulted domain.</td>
    </tr>
  </table>
</center>
<p> On some architectures, it is convenient to break out the annex
validation and cacheing to allow subsets of a <code>Context</code> to
be decached.  In such implementations, the <code>Context</code> is
considered <strong>cached</strong> only if all required annexes are
cached.
<p> On some architectures, there can be annexes that are not
required.  These generally correspond to coprocessors that are not
used by a particular process. On the x86, for example, the floating
point unit is unused by most processes, and it's state appears in a
separate annex node that need not be present for the domain to execute
instructions.  The first time such a domain executes a floating point
instruction it will fault, and the <strong>Context</strong> logic then
takes note of the need for a floating point register set.
<h2>Well-Formed Domains</h2>
A domain is well-formed if <em>all</em> of the following conditions
are satisfied:
<p>
<ul>
  <li> It's annex slots hold node keys.
  <li> It's fault code slot contains a number key.
  <li> All annex nodes hold only number keys.
  <li> All domain root register slots hold number keys.
  <li> All constituents (annex node, domain root, key registers node
       if present) are distinct.
</ul>
<p> A domain that is not well-formed is malformed. A malformed
domain's fault code is <strong>FC_MalformedDomain</strong>.  Attempts
to set such a domain running cause it's domain keeper (if one is
named) to be invoked.
<p> Note that the following conditions do <em>not</em> render a domain
malformed:
<ul>
  <li> A key of inappropriate type in the segment slot.  Such a domain
       is deemed to have a well-defined value in its address space
       register, which is a distinguished value indicating that all
       addresses are invalid.
  <li> A key of inappropriate type in the schedule slot.  Such a
       domain is deemed to be unable to execute instructions, but all
       of its register values are defined.
  <li> A key of inappropriate type in the key register node slot.
       Such a domain is deemed not to posess keys, and cannot perform
       invocations.
</ul>
<h2>Runnable Domains</h2>
<p> A domain is runnable if all of the following conditions hold:
<ul>
  <li> It is well formed,
  <li> It is in the running state (and therefore is occupied by a thread)
  <li> It has a zero fault code
</ul>
<p> A domain without a valid address space <em>is</em> runnable.  Such
a domain simply takes an access violation when attempting to access
it's first instruction.
<p> A domain without a valid schedule key is deemed to posess a
schedule conveying no CPU share.  It is runnable, but will not make
progress.
<hr>
<em>Copyright 1998 by Jonathan Shapiro.  All rights reserved.  For terms of 
redistribution, see the 
<a href="../legal/license/GPL.html">GNU General Public License</a></em>
</td><td width="10%">&nbsp;</td></tr></table></BODY>
</html>
